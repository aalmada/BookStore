@page "/"
@using BookStore.Client
@using ClientModels = BookStore.Client
@using BookStore.Shared.Models
@using BookStore.Web.Services
@using Microsoft.AspNetCore.Components.Authorization
@inject IGetBooksEndpoint ApiClient
@inject BookStoreEventsService EventsService
@inject OptimisticUpdateService OptimisticService
@inject IAddBookToFavoritesEndpoint AddFavoriteEndpoint
@inject IRemoveBookFromFavoritesEndpoint RemoveFavoriteEndpoint
@inject AuthenticationStateProvider AuthStateProvider
@inject ISnackbar Snackbar
@implements IAsyncDisposable
@rendermode InteractiveServer

<PageTitle>BookStore - Discover Your Next Great Read</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="mt-6">
    @* Hero Section *@
    <MudPaper Elevation="0" Class="pa-6 mb-6" Style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 16px;">
        <MudText Typo="Typo.h3" Color="Color.Surface" Class="mb-2">
            <MudIcon Icon="@Icons.Material.Filled.MenuBook" Size="Size.Large" /> BookStore
        </MudText>
        <MudText Typo="Typo.h6" Color="Color.Surface" Style="opacity: 0.9;">
            Discover your next great read from our curated collection
        </MudText>
    </MudPaper>

    @* Search Bar *@
    <MudPaper Elevation="2" Class="pa-4 mb-6" Style="border-radius: 12px;">
        <MudTextField @bind-Value="searchQuery"
                      Label="Search books"
                      Placeholder="Search by title, author, ISBN, or publisher..."
                      Variant="Variant.Outlined"
                      Adornment="Adornment.End"
                      AdornmentIcon="@Icons.Material.Filled.Search"
                      AdornmentColor="Color.Primary"
                      OnAdornmentClick="SearchBooks"
                      OnKeyUp="OnSearchKeyUp"
                      Clearable="true"
                      OnClearButtonClick="ClearSearch"
                      Immediate="true"
                      FullWidth="true"
                      Class="mud-text-field-large" />
    </MudPaper>

    @if (isLoading)
    {
        <MudGrid>
            @for (int i = 0; i < 8; i++)
            {
                <MudItem xs="12" sm="6" md="4" lg="3">
                    <MudCard Elevation="2">
                        <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="200px" />
                        <MudCardContent>
                            <MudSkeleton Width="80%" />
                            <MudSkeleton Width="60%" Class="mt-2" />
                            <MudSkeleton Width="40%" Class="mt-2" />
                        </MudCardContent>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
    }
    else if (errorMessage != null)
    {
        <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Class="mb-4">
            <MudText>@errorMessage</MudText>
            <MudButton OnClick="RetryLoad" Color="Color.Surface" Variant="Variant.Text" StartIcon="@Icons.Material.Filled.Refresh" Class="mt-2">
                Retry
            </MudButton>
        </MudAlert>
    }
    else if (pagedBooks != null)
    {
        @* Results Info *@
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
            Showing @pagedBooks.Items.Count of @pagedBooks.TotalItemCount books
            @if (!string.IsNullOrWhiteSpace(searchQuery))
            {
                <MudChip T="string" Size="Size.Small" Color="Color.Primary" Class="ml-2">@searchQuery</MudChip>
            }
        </MudText>

        @* Book Grid *@
        <MudGrid Spacing="4" Class="mb-6">
            @* Optimistic books (being saved) *@
            @foreach (var optimisticBook in OptimisticService.GetOptimisticBooks())
            {
                <MudItem xs="12" sm="6" md="4" lg="3">
                    <MudCard Elevation="4" Class="optimistic-card" Style="height: 100%; border-radius: 12px;">
                        <MudPaper Elevation="0" Height="200px" Style="background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); display: flex; align-items: center; justify-content: center;">
                            <MudIcon Icon="@Icons.Material.Filled.MenuBook" Size="Size.Large" Color="Color.Secondary" Style="font-size: 4rem;" />
                        </MudPaper>
                        <MudCardContent>
                            <MudText Typo="Typo.h6" Class="mb-2">@optimisticBook.Title</MudText>
                            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-1">
                                <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" /> @optimisticBook.AuthorNames
                            </MudText>
                            @if (!string.IsNullOrWhiteSpace(optimisticBook.PublisherName))
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary">
                                    <MudIcon Icon="@Icons.Material.Filled.Business" Size="Size.Small" /> @optimisticBook.PublisherName
                                </MudText>
                            }
                        </MudCardContent>
                        <MudCardActions>
                            <MudChip T="string" Size="Size.Small" Color="Color.Info" Icon="@Icons.Material.Filled.CloudUpload">Saving...</MudChip>
                        </MudCardActions>
                    </MudCard>
                </MudItem>
            }

            @* Actual books from server *@
            @foreach (var book in pagedBooks.Items)
            {
                <MudItem xs="12" sm="6" md="4" lg="3">
                    <MudCard Elevation="2" Class="book-card" Style="height: 100%; border-radius: 12px; transition: all 0.3s ease; position: relative; overflow: hidden;">
                         @* Heart Overlay *@
                        <AuthorizeView>
                            <Authorized>
                                <MudIconButton Icon="@(book.IsFavorite ? Icons.Material.Filled.Favorite : Icons.Material.Filled.FavoriteBorder)"
                                               Color="@(book.IsFavorite ? Color.Error : Color.Default)"
                                               OnClick="@(() => ToggleFavorite(book))"
                                               Class="favorite-overlay"
                                               Style="position: absolute; top: 12px; right: 12px; z-index: 10; background-color: rgba(255,255,255,0.8); backdrop-filter: blur(4px);"
                                               Size="Size.Medium" />
                            </Authorized>
                        </AuthorizeView>

                        <MudPaper Elevation="0" Height="200px" Style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center;">
                            <MudIcon Icon="@Icons.Material.Filled.MenuBook" Size="Size.Large" Color="Color.Surface" Style="font-size: 4rem;" />
                        </MudPaper>
                        <MudCardContent>
                            <MudText Typo="Typo.h6" Class="mb-2" Style="min-height: 3rem; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">
                                @book.Title
                            </MudText>
                            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-1">
                                <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" /> @string.Join(", ", book.Authors.Select(a => a.Name))
                            </MudText>
                            @if (book.Publisher != null)
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-1">
                                    <MudIcon Icon="@Icons.Material.Filled.Business" Size="Size.Small" /> @book.Publisher.Name
                                </MudText>
                            }
                            @if (book.PublicationDate.HasValue)
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary">
                                    <MudIcon Icon="@Icons.Material.Filled.CalendarToday" Size="Size.Small" /> @book.PublicationDate.Value.Year
                                </MudText>
                            }
                        </MudCardContent>
                        <MudCardActions>
                            <MudButton Href="@($"/book/{book.Id}")" Variant="Variant.Text" Color="Color.Primary" FullWidth="true" StartIcon="@Icons.Material.Filled.Visibility">
                                View Details
                            </MudButton>
                            <MudSpacer />
                            <MudChip T="string" Size="Size.Small" Icon="@Icons.Material.Filled.Favorite" Color="Color.Error" Variant="Variant.Text">
                                @book.LikeCount
                            </MudChip>
                        </MudCardActions>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>

        @* Pagination *@
        @if (pagedBooks.PageCount > 1)
        {
            <MudPaper Elevation="0" Class="d-flex justify-center pa-4">
                <MudPagination Count="@((int)pagedBooks.PageCount)" 
                              Selected="@currentPage" 
                              SelectedChanged="LoadPage"
                              Color="Color.Primary"
                              Variant="Variant.Filled"
                              ShowFirstButton="true"
                              ShowLastButton="true" />
            </MudPaper>
        }

        @* Empty State *@
        @if (pagedBooks.Items.Count == 0 && !string.IsNullOrWhiteSpace(searchQuery))
        {
            <MudPaper Elevation="0" Class="pa-8 text-center">
                <MudIcon Icon="@Icons.Material.Filled.SearchOff" Size="Size.Large" Color="Color.Secondary" Style="font-size: 6rem;" />
                <MudText Typo="Typo.h5" Class="mt-4 mb-2">No books found</MudText>
                <MudText Typo="Typo.body1" Color="Color.Secondary">
                    Try adjusting your search terms or <MudLink OnClick="ClearSearch" Color="Color.Primary">browse all books</MudLink>
                </MudText>
            </MudPaper>
        }
    }
</MudContainer>

@code {
    private ReactiveQuery<BookStore.Client.PagedListDtoOfBookDto>? bookQuery;
    private BookStore.Client.PagedListDtoOfBookDto? pagedBooks => bookQuery?.Data;
    private bool isLoading => bookQuery?.IsLoading ?? true;
    private string? errorMessage => bookQuery?.Error;

    private string searchQuery = string.Empty;
    private int currentPage = 1;
    private const int pageSize = 20;
    private System.Threading.Timer? debounceTimer;
    private System.Threading.Timer? cleanupTimer;

    [Inject] private ILogger<Home> Logger { get; set; } = default!;
    
    [CascadingParameter] private Task<AuthenticationState> AuthStateTask { get; set; } = default!;
    private System.Security.Claims.ClaimsPrincipal? user;

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to optimistic update changes
        OptimisticService.OnBooksChanged += HandleOptimisticBooksChanged;
        
        // Start SSE listening
        EventsService.StartListening();

        // Initialize ReactiveQuery
        bookQuery = new ReactiveQuery<BookStore.Client.PagedListDtoOfBookDto>(
            queryFn: FetchBooksAsync,
            eventsService: EventsService,
            invalidationPredicate: ShouldInvalidate,
            onStateChanged: StateHasChanged,
            logger: Logger
        );
        
        // Initial load
        await bookQuery.LoadAsync();
        
        // Start cleanup timer for stale optimistic books
        StartCleanupTimer();
    }

    protected override async Task OnParametersSetAsync()
    {
        var authState = await AuthStateTask;
        var newUser = authState.User;

        if (user == null || newUser.Identity?.Name != user.Identity?.Name || newUser.Identity?.IsAuthenticated != user.Identity?.IsAuthenticated)
        {
             user = newUser;
             if (user.Identity?.IsAuthenticated == true && bookQuery != null)
             {
                 await bookQuery.LoadAsync();
             }
        }
    }

    private async Task<BookStore.Client.PagedListDtoOfBookDto> FetchBooksAsync()
    {
        return await ApiClient.Execute(
            page: currentPage,
            pageSize: pageSize,
            search: string.IsNullOrWhiteSpace(searchQuery) ? string.Empty : searchQuery,
            api_version: "1.0",
            accept_Language: "en",
            x_Correlation_ID: Guid.NewGuid().ToString(),
            x_Causation_ID: string.Empty);
    }

    private bool ShouldInvalidate(BookStore.Shared.Notifications.IDomainEventNotification notification)
    {
        // Side effect: Confirm optimistic book if created
        if (notification is BookStore.Shared.Notifications.BookCreatedNotification bookCreated)
        {
            OptimisticService.ConfirmBook(bookCreated.EntityId);
            return true;
        }

        // Invalidate on any book or author/publisher change that might affect the list
        return notification is 
            BookStore.Shared.Notifications.BookUpdatedNotification or
            BookStore.Shared.Notifications.BookDeletedNotification or
            BookStore.Shared.Notifications.BookCoverUpdatedNotification or
            BookStore.Shared.Notifications.AuthorCreatedNotification or // Might affect search results or filters? Maybe overkill but safe.
            BookStore.Shared.Notifications.PublisherCreatedNotification;
    }

    private void OnSearchKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            _ = SearchBooks();
            return;
        }

        // Debounce search
        debounceTimer?.Dispose();
        debounceTimer = new System.Threading.Timer(async _ =>
        {
            await InvokeAsync(SearchBooks);
        }, null, 500, Timeout.Infinite);
    }

    private async Task SearchBooks()
    {
        currentPage = 1;
        if (bookQuery != null)
        {
            await bookQuery.LoadAsync();
        }
    }

    private void ClearSearch()
    {
        searchQuery = string.Empty;
        _ = SearchBooks();
    }

    private async Task LoadPage(int page)
    {
        currentPage = page;
        if (bookQuery != null)
        {
            await bookQuery.LoadAsync();
        }
    }

    private async Task ToggleFavorite(BookDto book)
    {
        var originalState = book.IsFavorite;
        
        // 1. Optimistic Update (Immediate Feedback)
        bookQuery?.MutateData(currentList =>
        {
            var items = currentList.Items.ToList();
            var index = items.FindIndex(b => b.Id == book.Id);
            if (index != -1)
            {
                items[index] = items[index] with 
                { 
                    IsFavorite = !originalState,
                    LikeCount = originalState ? items[index].LikeCount - 1 : items[index].LikeCount + 1
                };
            }
            return new BookStore.Client.PagedListDtoOfBookDto
            {
                Items = items,
                PageNumber = currentList.PageNumber,
                PageSize = currentList.PageSize,
                TotalItemCount = currentList.TotalItemCount,
                PageCount = currentList.PageCount,
                HasPreviousPage = currentList.HasPreviousPage,
                HasNextPage = currentList.HasNextPage
            };
        });

        // 2. Call API
        try
        {
            if (originalState) // Was favorite, so remove
            {
                await RemoveFavoriteEndpoint.Execute(book.Id);
                Snackbar.Add("Removed from favorites", Severity.Success);
            }
            else // Was not favorite, so add
            {
                await AddFavoriteEndpoint.Execute(book.Id);
                 Snackbar.Add("Added to favorites", Severity.Success);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to toggle favorite for book {BookId}", book.Id);
            
            // 3. Rollback on failure
            bookQuery?.MutateData(currentList =>
            {
                var items = currentList.Items.ToList();
                var index = items.FindIndex(b => b.Id == book.Id);
                if (index != -1)
                {
                    items[index] = items[index] with 
                    { 
                        IsFavorite = originalState,
                        LikeCount = originalState ? items[index].LikeCount + 1 : items[index].LikeCount - 1
                    };
                }
                return new BookStore.Client.PagedListDtoOfBookDto
                {
                    Items = items,
                    PageNumber = currentList.PageNumber,
                    PageSize = currentList.PageSize,
                    TotalItemCount = currentList.TotalItemCount,
                    PageCount = currentList.PageCount,
                    HasPreviousPage = currentList.HasPreviousPage,
                    HasNextPage = currentList.HasNextPage
                };
            });
            
             Snackbar.Add($"Failed: {ex.Message}", Severity.Error);
        }
    }

    private async Task RetryLoad()
    {
        if (bookQuery != null)
        {
            await bookQuery.LoadAsync();
        }
    }

    public void Dispose()
    {
        debounceTimer?.Dispose();
    }
    
    private void HandleOptimisticBooksChanged()
    {
        // Refresh UI when optimistic books change
        InvokeAsync(StateHasChanged);
    }
    
    private void StartCleanupTimer()
    {
        // Clean up stale optimistic books every 5 seconds
        cleanupTimer = new System.Threading.Timer(_ =>
        {
            OptimisticService.CleanupStaleBooks();
        }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
    }
    
    public async ValueTask DisposeAsync()
    {
        bookQuery?.Dispose();
        OptimisticService.OnBooksChanged -= HandleOptimisticBooksChanged;
        
        // Dispose timers
        debounceTimer?.Dispose();
        cleanupTimer?.Dispose();
    }
}

<style>
    .book-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2) !important;
    }

    .optimistic-card {
        animation: pulse 2s ease-in-out infinite;
        opacity: 0.9;
    }

    @@keyframes pulse {
        0%, 100% {
            opacity: 0.9;
        }
        50% {
            opacity: 1;
        }
    }

    .mud-text-field-large .mud-input {
        font-size: 1.1rem;
    }
</style>
