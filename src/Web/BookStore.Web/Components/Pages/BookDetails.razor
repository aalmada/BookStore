@page "/book/{id:guid}"
@using BookStore.Web.Services
@using BookStore.Client
@using ClientModels = BookStore.Client
@using BookStore.Shared.Models
@using Microsoft.AspNetCore.Components.Authorization
@inject IGetBookEndpoint ApiClient
@inject NavigationManager Navigation
@inject IAddBookToFavoritesEndpoint AddFavoriteEndpoint
@inject IRemoveBookFromFavoritesEndpoint RemoveFavoriteEndpoint
@inject AuthenticationStateProvider AuthStateProvider
@inject ISnackbar Snackbar
@implements IAsyncDisposable
@rendermode InteractiveServer

<PageTitle>@(book?.Title ?? "Book Details") - BookStore</PageTitle>

<MudContainer MaxWidth="MaxWidth.Large" Class="mt-6">
    @if (isLoading)
    {
        <MudPaper Elevation="2" Class="pa-6" Style="border-radius: 12px;">
            <MudGrid>
                <MudItem xs="12" md="4">
                    <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="400px" />
                </MudItem>
                <MudItem xs="12" md="8">
                    <MudSkeleton Width="60%" Height="60px" Class="mb-4" />
                    <MudSkeleton Width="40%" Class="mb-6" />
                    <MudSkeleton Width="100%" Height="200px" />
                </MudItem>
            </MudGrid>
        </MudPaper>
    }
    else if (errorMessage != null)
    {
        <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Class="mb-4">
            <MudText Typo="Typo.h6" Class="mb-2">@errorMessage</MudText>
            <MudButton OnClick="RetryLoad" Color="Color.Surface" Variant="Variant.Text" StartIcon="@Icons.Material.Filled.Refresh">
                Retry
            </MudButton>
        </MudAlert>
        <MudButton Href="/" Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.ArrowBack">
            Back to Catalog
        </MudButton>
    }
    else if (book != null)
    {
        @* Breadcrumbs *@
        <MudBreadcrumbs Items="_breadcrumbItems" Class="mb-4" />

        <MudPaper Elevation="2" Class="pa-6" Style="border-radius: 12px;">
            <MudGrid>
                @* Book Cover *@
                <MudItem xs="12" md="4">
                    <MudPaper Elevation="4" Style="border-radius: 12px; overflow: hidden; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); height: 500px; display: flex; align-items: center; justify-content: center;">
                        <MudIcon Icon="@Icons.Material.Filled.MenuBook" Size="Size.Large" Color="Color.Surface" Style="font-size: 10rem;" />
                    </MudPaper>
                </MudItem>

                @* Book Information *@
                <MudItem xs="12" md="8">
                    <MudText Typo="Typo.h3" Class="mb-3">@book.Title</MudText>

                    @if (book.Authors.Count > 0)
                    {
                        <MudText Typo="Typo.h6" Color="Color.Secondary" Class="mb-4">
                            <MudIcon Icon="@Icons.Material.Filled.Person" Size="Size.Small" /> by @string.Join(", ", book.Authors.Select(a => a.Name))
                        </MudText>
                    }

                     @* Favorite Button *@
                     <AuthorizeView>
                        <Authorized>
                            <MudButton Variant="Variant.Outlined" 
                                       Color="@(book.IsFavorite ? Color.Error : Color.Default)"
                                       StartIcon="@(book.IsFavorite ? Icons.Material.Filled.Favorite : Icons.Material.Filled.FavoriteBorder)"
                                       OnClick="@(() => ToggleFavorite(book))"
                                       Class="mb-4">
                                @(book.IsFavorite ? "Remove from Favorites" : "Add to Favorites") (@book.LikeCount)
                            </MudButton>
                        </Authorized>
                     </AuthorizeView>

                    @* Book Details Card *@
                    <MudCard Elevation="0" Class="mb-4" Style="background-color: rgba(0,0,0,0.02);">
                        <MudCardContent>
                            <MudText Typo="Typo.h6" Class="mb-3">Book Information</MudText>
                            <MudStack Spacing="2">
                                @if (!string.IsNullOrWhiteSpace(book.Isbn))
                                {
                                    <MudStack Row="true" AlignItems="AlignItems.Center">
                                        <MudIcon Icon="@Icons.Material.Filled.QrCode" Size="Size.Small" Color="Color.Secondary" />
                                        <MudText Typo="Typo.body2"><strong>ISBN:</strong> @book.Isbn</MudText>
                                    </MudStack>
                                }

                                @if (book.Publisher != null)
                                {
                                    <MudStack Row="true" AlignItems="AlignItems.Center">
                                        <MudIcon Icon="@Icons.Material.Filled.Business" Size="Size.Small" Color="Color.Secondary" />
                                        <MudText Typo="Typo.body2"><strong>Publisher:</strong> @book.Publisher.Name</MudText>
                                    </MudStack>
                                }

                                @if (!string.IsNullOrWhiteSpace(book.LanguageName))
                                {
                                    <MudStack Row="true" AlignItems="AlignItems.Center">
                                        <MudIcon Icon="@Icons.Material.Filled.Language" Size="Size.Small" Color="Color.Secondary" />
                                        <MudText Typo="Typo.body2"><strong>Language:</strong> @book.LanguageName</MudText>
                                    </MudStack>
                                }

                                @if (book.PublicationDate.HasValue)
                                {
                                    <MudStack Row="true" AlignItems="AlignItems.Center">
                                        <MudIcon Icon="@Icons.Material.Filled.CalendarToday" Size="Size.Small" Color="Color.Secondary" />
                                        <MudText Typo="Typo.body2"><strong>Published:</strong> @book.PublicationDate.Value.ToDisplayString()</MudText>
                                    </MudStack>
                                }
                            </MudStack>
                        </MudCardContent>
                    </MudCard>

                    @* Description *@
                    @if (!string.IsNullOrWhiteSpace(book.Description))
                    {
                        <MudCard Elevation="0" Style="background-color: rgba(0,0,0,0.02);">
                            <MudCardContent>
                                <MudText Typo="Typo.h6" Class="mb-3">Description</MudText>
                                <MudText Typo="Typo.body1">@book.Description</MudText>
                            </MudCardContent>
                        </MudCard>
                    }
                </MudItem>
            </MudGrid>
        </MudPaper>

        @* Actions *@
        <MudStack Row="true" Class="mt-6" Spacing="2">
            <MudButton Href="/" Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.ArrowBack">
                Back to Catalog
            </MudButton>
        </MudStack>
    }
</MudContainer>

@code {
    [Parameter]
    public Guid Id { get; set; }

    private ReactiveQuery<BookDto?>? bookQuery;
    private BookDto? book => bookQuery?.Data;
    private string? errorMessage => bookQuery?.Error;
    private bool isLoading => bookQuery?.IsLoading ?? true;
    private List<BreadcrumbItem> _breadcrumbItems = new();
    
    [Inject] private ILogger<BookDetails> Logger { get; set; } = default!;
    
    [CascadingParameter] private Task<AuthenticationState> AuthStateTask { get; set; } = default!;
    private System.Security.Claims.ClaimsPrincipal? user;

    protected override async Task OnInitializedAsync()
    {
        // Start SSE listening (ensure it's started if specific page loaded directly)
        EventsService.StartListening();
        
        await InitializeQueryAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        // Reload when ID parameter changes
        // Note: queryFn captures 'Id', so we need to reload if Id changes.
        // But ReactiveQuery caches the function. We strictly should allow updating the function or creating new query.
        // Easiest is to recreate the query if ID changes.
        if (bookQuery != null) // If checking existing query
        {
             // We can just rely on the fact that if OnParametersSetAsync runs, Id might have changed.
             // But we need to check if it actually changed to avoid loop?
             // Actually OnParametersSetAsync runs on standard parameter set.
             // We'll manage checking inside InitializeQueryAsync logic or just re-init.
             await InitializeQueryAsync();

        }

        var authState = await AuthStateTask;
        var newUser = authState.User;

        if (user == null || newUser.Identity?.Name != user.Identity?.Name || newUser.Identity?.IsAuthenticated != user.Identity?.IsAuthenticated)
        {
             user = newUser;
             if (user.Identity?.IsAuthenticated == true && bookQuery != null)
             {
                 await bookQuery.LoadAsync();
             }
        }
    }

    private async Task InitializeQueryAsync()
    {
        // Dispose previous if exists
        bookQuery?.Dispose();

        bookQuery = new ReactiveQuery<BookDto?>(
            queryFn: async () => {
                try 
                {
                    return await ApiClient.Execute(
                        id: Id,
                        api_version: "1.0",
                        accept_Language: "en",
                        x_Correlation_ID: Guid.NewGuid().ToString(),
                        x_Causation_ID: string.Empty);
                }
                catch (Refit.ApiException apiEx) when (apiEx.StatusCode == System.Net.HttpStatusCode.NotFound)
                {
                    throw new Exception("Book not found. It may have been removed or the ID is incorrect.");
                }
            },
            eventsService: EventsService,
            invalidationPredicate: n => (n is BookStore.Shared.Notifications.BookUpdatedNotification or BookStore.Shared.Notifications.BookDeletedNotification or BookStore.Shared.Notifications.BookCoverUpdatedNotification && n.EntityId == Id) || n is BookStore.Shared.Notifications.UserUpdatedNotification,
            onStateChanged: StateHasChanged,
            logger: Logger
        );

        await bookQuery.LoadAsync();
        UpdateBreadcrumbs();
    }

    private async Task<BookDto?> FetchBookAsync()
    {
        try 
        {
            return await ApiClient.Execute(
                id: Id,
                api_version: "1.0",
                accept_Language: "en",
                x_Correlation_ID: Guid.NewGuid().ToString(),
                x_Causation_ID: string.Empty);
        }
        catch (Refit.ApiException apiEx) when (apiEx.StatusCode == System.Net.HttpStatusCode.NotFound)
        {
             throw new Exception("Book not found. It may have been removed or the ID is incorrect.");
        }
    }

    private bool ShouldInvalidate(BookStore.Shared.Notifications.IDomainEventNotification notification)
    {
        // Only invalidate if the event is about THIS book
        if (notification is BookStore.Shared.Notifications.BookUpdatedNotification updated && updated.EntityId == Id) return true;
        if (notification is BookStore.Shared.Notifications.BookCoverUpdatedNotification coverUpdated && coverUpdated.EntityId == Id) return true;
        
        // If deleted, we should probably handle that... 
        // bookQuery will just fail to fetch or return null?
        if (notification is BookStore.Shared.Notifications.BookDeletedNotification deleted && deleted.EntityId == Id) return true;

        return false;
    }

    private void UpdateBreadcrumbs()
    {
        if (book != null)
        {
            _breadcrumbItems = new List<BreadcrumbItem>
            {
                new BreadcrumbItem("Home", href: "/", icon: Icons.Material.Filled.Home),
                new BreadcrumbItem(book.Title ?? "Book", href: null, disabled: true)
            };
        }
    }

    private async Task RetryLoad()
    {
        if (bookQuery != null)
        {
            await bookQuery.LoadAsync();
            UpdateBreadcrumbs();
        }
    }

    private async Task ToggleFavorite(BookDto bookToToggle)
    {
        var originalState = bookToToggle.IsFavorite;

        // 1. Optimistic
        bookQuery?.MutateData(current => current == null ? null : current with 
        { 
            IsFavorite = !originalState,
            LikeCount = originalState ? current.LikeCount - 1 : current.LikeCount + 1
        });

        // 2. API Call
        try
        {
            if (originalState)
            {
                await RemoveFavoriteEndpoint.Execute(bookToToggle.Id);
                Snackbar.Add("Removed from favorites", Severity.Success);
            }
            else
            {
                await AddFavoriteEndpoint.Execute(bookToToggle.Id);
                Snackbar.Add("Added to favorites", Severity.Success);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to toggle favorite for book {BookId}", bookToToggle.Id);
            // 3. Rollback
            bookQuery?.MutateData(current => current == null ? null : current with 
            { 
                IsFavorite = originalState,
                LikeCount = originalState ? current.LikeCount + 1 : current.LikeCount - 1
            });
            Snackbar.Add($"Failed: {ex.Message}", Severity.Error);
        }
    }
    
    // Inject EventsService which wasn't injected before
    [Inject] private BookStoreEventsService EventsService { get; set; } = default!;
    
    public async ValueTask DisposeAsync()
    {
        bookQuery?.Dispose();
    }
}
