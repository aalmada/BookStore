@page "/register"
@using BookStore.Web.Services
@inject AuthenticationService AuthService
@inject PasskeyService PasskeyService
@inject JwtAuthenticationStateProvider AuthStateProvider
@inject NavigationManager Navigation
@inject BookStoreEventsService EventsService
@implements IDisposable
@inject IJSRuntime JS
@using Microsoft.JSInterop
@rendermode InteractiveServer

<PageTitle>Register - BookStore</PageTitle>

<MudContainer MaxWidth="MaxWidth.Small" Class="mt-8">
    <MudPaper Elevation="4" Class="pa-8" Style="border-radius: 12px;">
        <MudText Typo="Typo.h4" Align="Align.Center" Class="mb-6">
            <MudIcon Icon="@Icons.Material.Filled.PersonAdd" Size="Size.Large" Class="mr-2" />
            Create Account
        </MudText>

        @if (!string.IsNullOrEmpty(errorMessage))
        {
            <MudAlert Severity="Severity.Error" Class="mb-4">@errorMessage</MudAlert>
        }

        @if (registrationSuccess)
        {
            <MudAlert Severity="Severity.Success" Class="mb-4">
                Registration successful!
                @if (requiresVerification)
                {
                   <text> Please check your email to verify your account.</text>
                }
                else
                {
                   <text> Redirecting to login...</text>
                }
            </MudAlert>
        }

        <MudTabs Elevation="0" Rounded="true" ApplyEffectsToContainer="true" PanelClass="px-4 py-6">
            <MudTabPanel Text="Standard" Icon="@Icons.Material.Filled.Email">
                <MudForm @ref="form">
                    <MudTextField @bind-Value="email"
                                  Label="Email"
                                  Variant="Variant.Outlined"
                                  Required="true"
                                  RequiredError="Email is required"
                                  Validation="@(new Func<string, string?>(ValidateEmail))"
                                  Class="mb-4" />

                    <MudTextField @bind-Value="password"
                                  Label="Password"
                                  Variant="Variant.Outlined"
                                  InputType="InputType.Password"
                                  Required="true"
                                  RequiredError="Password is required"
                                  OnBlur="ValidatePasswordStrength"
                                  Class="mb-4" />

                    @if (passwordErrors.Any())
                    {
                        <MudAlert Severity="Severity.Warning" Class="mb-4">
                            <MudText Typo="Typo.body2" Class="mb-2"><strong>Password must meet the following requirements:</strong></MudText>
                            <ul style="margin: 0; padding-left: 20px;">
                                @foreach (var error in passwordErrors)
                                {
                                    <li>@error</li>
                                }
                            </ul>
                        </MudAlert>
                    }

                    <MudTextField @bind-Value="confirmPassword"
                                  Label="Confirm Password"
                                  Variant="Variant.Outlined"
                                  InputType="InputType.Password"
                                  Required="true"
                                  RequiredError="Please confirm your password"
                                  Validation="@(new Func<string, string?>(ValidateConfirmPassword))"
                                  Class="mb-4" />

                    <MudButton Variant="Variant.Filled"
                               Color="Color.Primary"
                               FullWidth="true"
                               Size="Size.Large"
                               OnClick="HandleRegister"
                               Disabled="isLoading || passwordErrors.Any()"
                               Class="mb-4">
                        @if (isLoading)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Creating account...</span>
                        }
                        else
                        {
                            <span>Register</span>
                        }
                    </MudButton>
                </MudForm>
            </MudTabPanel>
            <MudTabPanel Text="Passkey" Icon="@Icons.Material.Filled.Fingerprint">
                <MudText Typo="Typo.body1" Class="mb-4">
                    Register securely without a password using your device's biometric authenticator (FaceID, TouchID) or security key.
                </MudText>
                
                <MudForm>
                    <MudTextField @bind-Value="email"
                                  Label="Email"
                                  Variant="Variant.Outlined"
                                  Required="true"
                                  RequiredError="Email is required"
                                  Validation="@(new Func<string, string?>(ValidateEmail))"
                                  Immediate="true"
                                  Class="mb-4" />

                    <MudButton Variant="Variant.Outlined"
                               StartIcon="@Icons.Material.Filled.Fingerprint"
                               Color="Color.Secondary"
                               FullWidth="true"
                               Size="Size.Large"
                               OnClick="RegisterWithPasskey"
                               Disabled="isLoading || string.IsNullOrEmpty(email)"
                               Class="mb-4">
                        @if (isLoading)
                        {
                            <MudProgressCircular Size="Size.Small" Indeterminate="true" Class="mr-2" />
                            <span>Creating account...</span>
                        }
                        else
                        {
                            <span>Register with Passkey</span>
                        }
                    </MudButton>
                </MudForm>
            </MudTabPanel>
        </MudTabs>

        <MudDivider Class="my-4" />

        <MudText Align="Align.Center">
            Already have an account?
            <MudLink Href="/login" Color="Color.Primary">Login here</MudLink>
        </MudText>
    </MudPaper>
</MudContainer>

@code {
    MudForm? form;
    string email = string.Empty;
    string password = string.Empty;
    string confirmPassword = string.Empty;
    string? errorMessage;
    bool isLoading;
    bool registrationSuccess;
    bool requiresVerification;
    List<string> passwordErrors = new();

    async Task HandleRegister()
    {
        if (form == null)
        {
            return;
        }

        await form.Validate();
        if (!form.IsValid)
        {
            return;
        }

        ValidatePasswordStrength();
        if (passwordErrors.Any())
        {
            return;
        }

        isLoading = true;
        errorMessage = null;

        try
        {
            var result = await AuthService.RegisterAsync(email, password);

            if (result.Success)
            {
                registrationSuccess = true;
                requiresVerification = true; // Assume verification is required unless we know otherwise (API could return this info)
                // For MVP, if success and no token returned -> verification needed.
                // If token returned -> auto login.
                // Our API implementation returns tokens immediately if not verified?
                // Wait, if EmailConfirmed is false, does logic prevent login? 
                // Currently RegisterAsync returns tokens regardless of EmailConfirmed status (it's set to false but user is created and tokens issued).
                // If the requirement is "must verify to login", then RegisterAsync shouldn't return tokens or Login should fail.
                // However, the current code issues tokens. 
                // So verification is "optional" for instant access? 
                // The prompt "when email service is disabled, the account should be validated by default" implies logic.
                // If enabled, email is sent.
                // If we want to FORCE verification, we should NOT return tokens in RegisterAsync if !EmailConfirmed.
                // But let's assume for now, we just notify.
                
                // Correction based on typical flow:
                // If verification enabled, we want the user to click the link.
                // If tokens are returned, they are logged in.
                // We should check the result.AccessToken.
                
               requiresVerification = false; // Default to old behavior until we know better.
               // Actually, `RegisterResult` does not have AccessToken. `AuthenticationService.RegisterAsync` returns `RegisterResult`.
               // `LoginResult` has AccessToken.
               // `AuthenticationService.RegisterAsync` calls endpoint which returns LoginResponse? No, `IIdentityRegisterEndpoint` returns Task (void).
               // Ah, `JwtAuthenticationEndpoints.RegisterAsync` returns `LoginResponse`. 
               // But `IIdentityRegisterEndpoint` is defined as `Task Execute`. It ignores the response body?
               // Let's check `IIdentityEndpoints.cs`: `Task Execute` -> it effectively ignores the JSON body unless wrapped in Task<LoginResponse>.
               // `AuthenticationService.RegisterAsync` returns `RegisterResult` (Success/Error).
               
               // So the client doesn't get the token automatically here.
               // This means the user is redirected to Login.
               // If verification is on, Login might fail or succeed depending on policy (ASP.NET Core Identity by default allows login unless configured otherwise).

               // Design decision: We show "Check email".
               requiresVerification = true; // Safe default for UI message.
            }
            else
            {
                errorMessage = result.Error ?? "Registration failed";
            }
        }
        finally
        {
            isLoading = false;
        }
    }
    
    async Task RegisterWithPasskey()
    {
        errorMessage = null;
        var emailError = ValidateEmail(email);
        if (emailError != null)
        {
             errorMessage = emailError;
             return;
        }

        isLoading = true;
        try 
        {
            // 1. Get Options
            var (options, error) = await PasskeyService.GetCreationOptionsAsync(email);
            if (string.IsNullOrEmpty(options))
            {
                 errorMessage = error ?? "Failed to initialize passkey registration. User may already exist.";
                 return;
            }
            
            // Extract userId from the options response
            string? userId = null;
            string optionsJson = options;
            try
            {
                using var doc = System.Text.Json.JsonDocument.Parse(options);
                if (doc.RootElement.TryGetProperty("userId", out var userIdElem))
                {
                    userId = userIdElem.GetString();
                }
                
                // Get the actual options object
                if (doc.RootElement.TryGetProperty("options", out var optionsElem))
                {
                    optionsJson = optionsElem.GetRawText();
                }
            }
            catch
            {
                // If parsing fails, use the whole response as options
            }
            
            // 2. JS WebAuthn Create
            var credentialJson = await JS.InvokeAsync<string>("passkey.register", optionsJson);
            
            // 3. Submit to Server with userId
            var result = await PasskeyService.RegisterPasskeyAsync(credentialJson, email, userId);
            
            if (result != null && result.Success)
            {
                if (!string.IsNullOrEmpty(result.AccessToken))
                {
                    // Auto-login success (when email verification is not required)
                    AuthStateProvider.NotifyUserAuthentication(result.AccessToken);
                    registrationSuccess = true;
                    requiresVerification = false;
                    await Task.Delay(2000);
                    Navigation.NavigateTo("/");
                }
                else
                {
                    // Email verification required
                    registrationSuccess = true;
                    requiresVerification = true;
                }
            }
            else
            {
                errorMessage = result?.Error ?? "Passkey registration failed on server.";
            }

        }
        catch (Exception ex)
        {
            errorMessage = $"Error: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    
    }

    protected override void OnInitialized()
    {
        EventsService.OnNotificationReceived += HandleNotification;
        EventsService.StartListening();
    }

    void HandleNotification(BookStore.Shared.Notifications.IDomainEventNotification notification)
    {
        if (notification is BookStore.Shared.Notifications.UserVerifiedNotification userVerified)
        {
            if (userVerified.Email.Equals(email, StringComparison.OrdinalIgnoreCase))
            {
                InvokeAsync(async () =>
                {
                    registrationSuccess = true;
                    requiresVerification = false;
                    StateHasChanged();
                    await Task.Delay(2000);
                    Navigation.NavigateTo("/login");
                });
            }
        }
    }

    public void Dispose()
    {
        EventsService.OnNotificationReceived -= HandleNotification;
    }

    void ValidatePasswordStrength()
    {
        passwordErrors.Clear();

        if (string.IsNullOrWhiteSpace(password))
        {
            return;
        }

        if (password.Length < 8)
        {
            passwordErrors.Add("At least 8 characters");
        }

        if (!password.Any(char.IsUpper))
        {
            passwordErrors.Add("At least one uppercase letter");
        }

        if (!password.Any(char.IsLower))
        {
            passwordErrors.Add("At least one lowercase letter");
        }

        if (!password.Any(char.IsDigit))
        {
            passwordErrors.Add("At least one number");
        }

        if (!password.Any(ch => !char.IsLetterOrDigit(ch)))
        {
            passwordErrors.Add("At least one special character");
        }
    }

    static string? ValidateEmail(string email)
    {
        if (string.IsNullOrWhiteSpace(email))
        {
            return "Email is required";
        }

        if (!email.Contains('@'))
        {
            return "Invalid email format";
        }

        return null;
    }

    string? ValidateConfirmPassword(string confirmPwd)
    {
        if (string.IsNullOrWhiteSpace(confirmPwd))
        {
            return "Please confirm your password";
        }

        if (confirmPwd != password)
        {
            return "Passwords do not match";
        }

        return null;
    }
}
