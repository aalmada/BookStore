@page "/account/passkeys"
@using Microsoft.AspNetCore.Authorization
@using BookStore.Web.Services
@using BookStore.Client
@inject PasskeyService PasskeyService
@inject IJSRuntime JS
@inject ISnackbar Snackbar
@inject NavigationManager Navigation
@inject BookStore.Web.Services.ErrorLocalizationService ErrorLocalizer
@attribute [Authorize]

<PageTitle>Manage Passkeys</PageTitle>

<MudContainer MaxWidth="MaxWidth.Small" Class="mt-8">
    <MudText Typo="Typo.h4" GutterBottom="true">Manage Passkeys</MudText>
    <MudText Typo="Typo.body1" Class="mb-4">
        Register a passkey to sign in without a password.
        <MudLink Href="/account/password" Color="Color.Primary">Manage your password here.</MudLink>
    </MudText>

    <MudPaper Class="pa-4">
        @if (_isSupported == null)
        {
            <MudProgressCircular Indeterminate="true"/>
        }
        else if (_isSupported == false)
        {
            <MudAlert Severity="Severity.Warning">Your device does not support passkeys.</MudAlert>
        }
        else
        {
            <MudButton Variant="Variant.Filled"
                       Color="Color.Primary"
                       OnClick="RegisterPasskey"
                       Disabled="@_isLoading">
                @(_isLoading ? "Registering..." : "Register New Passkey")
            </MudButton>

            @if (!string.IsNullOrEmpty(_statusMessage))
            {
                <MudText Color="@(_isError ? Color.Error : Color.Success)" Class="mt-2">@_statusMessage</MudText>
            }
        }
    </MudPaper>

    <MudText Typo="Typo.h6" Class="mt-6 mb-2">Your Passkeys</MudText>
    <MudPaper Class="pa-4">
        @if (_passkeys == null)
        {
            <MudProgressCircular Indeterminate="true" Size="Size.Small"/>
        }
        else if (_passkeys.Count == 0)
        {
            <MudText Typo="Typo.body2" Color="Color.Secondary">No passkeys registered yet.</MudText>
        }
        else
        {
            <MudList T="PasskeyInfo">
                @foreach (var passkey in _passkeys)
                {
                    <MudListItem T="PasskeyInfo">
                        <div class="d-flex justify-space-between align-center" style="width: 100%;">
                            <div>
                                <MudText Typo="Typo.body1">
                                    <MudIcon Icon="@Icons.Material.Filled.Key" Size="Size.Small" Class="mr-2"/>@passkey.Name
                                </MudText>
                                @if (passkey.CreatedAt.HasValue)
                                {
                                    <MudText Typo="Typo.caption" Color="Color.Secondary">
                                        Added @passkey.CreatedAt.Value.LocalDateTime.ToString("MMM dd, yyyy")
                                    </MudText>
                                }
                            </div>
                            <MudIconButton Icon="@Icons.Material.Filled.Delete"
                                           Color="Color.Error"
                                           Size="Size.Small"
                                           OnClick="@(() => DeletePasskey(passkey.Id))"
                                           Disabled="@_isDeleting"/>
                        </div>
                    </MudListItem>
                }
            </MudList>
        }
    </MudPaper>
</MudContainer>

@code {
    private bool? _isSupported;
    private bool _isLoading;
    private bool _isDeleting;
    private string? _statusMessage;
    private bool _isError;
    private IReadOnlyList<PasskeyInfo>? _passkeys;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                _isSupported = await JS.InvokeAsync<bool>("passkey.isSupported");
                _passkeys = await PasskeyService.ListPasskeysAsync();
                StateHasChanged();
            }
            catch
            {
                _isSupported = false;
                _passkeys = [];
                StateHasChanged();
            }
        }
    }

    private async Task RegisterPasskey()
    {
        _isLoading = true;
        _statusMessage = null;
        _isError = false;

        try
        {
            // 1. Get Options
            var optionsResult = await PasskeyService.GetCreationOptionsAsync();
            if (optionsResult.IsFailure)
            {
                ShowError(optionsResult.Error.Message ?? "Failed to get passkey options from server.");
                return;
            }

            var optionsJson = optionsResult.Value.OptionsJson;

            // 2. Create Credential via JS
            var credentialJson = await JS.InvokeAsync<string>("passkey.register", optionsJson);

            // 3. Register on Server
            var result = await PasskeyService.RegisterPasskeyAsync(credentialJson);
            if (result.IsSuccess)
            {
                _statusMessage = "Passkey registered successfully!";
                Snackbar.Add("Passkey registered!", Severity.Success);
                // Refresh the list
                _passkeys = await PasskeyService.ListPasskeysAsync();
            }
            else
            {
                ShowError(ErrorLocalizer.GetLocalizedMessage(result.Error) ?? "Failed to register passkey on server.");
            }
        }
        catch (Exception ex)
        {
            var message = ex.Message;
            if (message.Contains("Error:"))
            {
                var parts = message.Split("Error:", 2);
                message = parts[^1].Trim();
            }

            _statusMessage = ErrorLocalizer.GetLocalizedMessage(message);
            ShowError(_statusMessage);
        }
        finally
        {
            _isLoading = false;
        }
    }

    private async Task DeletePasskey(string id)
    {
        _isDeleting = true;
        try
        {
            var result = await PasskeyService.DeletePasskeyAsync(id);
            if (result.IsSuccess)
            {
                Snackbar.Add("Passkey deleted.", Severity.Success);
                _passkeys = await PasskeyService.ListPasskeysAsync();
            }
            else
            {
                Snackbar.Add(ErrorLocalizer.GetLocalizedMessage(result.Error) ?? "Failed to delete passkey.", Severity.Error);
            }
        }
        finally
        {
            _isDeleting = false;
        }
    }

    private void ShowError(string message)
    {
        _statusMessage = message;
        _isError = true;
        Snackbar.Add(message, Severity.Error);
    }

}

