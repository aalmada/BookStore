@page "/"
@using BookStore.Client
@using ClientModels = BookStore.Client
@using BookStore.Shared.Models
@using BookStore.Web.Services
@using Microsoft.AspNetCore.Components.Authorization
@using BookStore.Web.Components.Catalog
@inject IBooksClient BooksClient
@inject BookStoreEventsService EventsService
@inject OptimisticUpdateService OptimisticService
@inject AuthenticationStateProvider AuthStateProvider
@inject ISnackbar Snackbar
@inject CatalogService CatalogService
@implements IDisposable
@rendermode InteractiveServer

@inject IAuthorsClient AuthorsClient
@inject ICategoriesClient CategoriesClient
@inject IPublishersClient PublishersClient

@inject TenantService TenantService
@inject CurrencyService CurrencyService
@using BookStore.Web.Infrastructure

<PageTitle>@TenantService.CurrentTenantName - Discover Your Next Great Read</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge">
@* ─── Hero Section ──────────────────────────────────────────────────── *@
<MudPaper Elevation="0" Class="mb-6 hero-banner"
          Style="@((!string.IsNullOrEmpty(TenantService.CurrentTenantHeroBannerUrl)
              ? $"background: url('{TenantService.CurrentTenantHeroBannerUrl}') center/cover no-repeat"
              : $"background: linear-gradient(135deg, {TenantService.CurrentTenantPrimaryColor} 0%, {TenantService.CurrentTenantSecondaryColor} 100%)")
              + "; border-radius: 20px; overflow: hidden; min-height: 320px; position: relative; display: flex; align-items: flex-end;")">
    @* overlay for readability over images *@
    <div class="hero-overlay" style="position: absolute; inset: 0; background: linear-gradient(to top, rgba(0,0,0,0.65) 0%, rgba(0,0,0,0.1) 60%); border-radius: 20px;"></div>
    <div style="position: relative; z-index: 1; padding: 2.5rem;">
        <MudText Typo="Typo.h3" Style="color: #fff; font-weight: 700; letter-spacing: -0.03em; text-shadow: 0 2px 12px rgba(0,0,0,0.35);" Class="mb-2">
            @TenantService.CurrentTenantName
        </MudText>
        <MudText Typo="Typo.h6" Style="color: rgba(255,255,255,0.88); font-weight: 400;" Class="mb-4">
            @TenantService.CurrentTenantTagline
        </MudText>
    </div>
</MudPaper>

<MudGrid Spacing="6">
@* Filters Sidebar *@
<MudItem xs="12" md="3">
    <MudPaper Class="pa-4 mb-6 filter-panel" Elevation="2" Style="border-radius: 16px;">
        <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Class="mb-4">
            <MudText Typo="Typo.h6" Style="font-weight: 700; letter-spacing: -0.01em;">
                <MudIcon Icon="@Icons.Material.Filled.Tune" Class="mr-1"/> Filters
            </MudText>
        </MudStack>

        <MudStack Spacing="3">
            @* Sort *@
            <MudSelect T="string" Label="Sort By" Value="@sortBy" AnchorOrigin="Origin.BottomCenter" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true" ValueChanged="@(async (string v) =>
                                                                                                                                                                                 {
                                                                                                                                                                                     sortBy = v;
                                                                                                                                                                                     await SearchBooks();
                                                                                                                                                                                 })">
                <MudSelectItem Value="@("title")">Title</MudSelectItem>
                <MudSelectItem Value="@("date")">Date Added</MudSelectItem>
                <MudSelectItem Value="@("publisher")">Publisher</MudSelectItem>
            </MudSelect>

            <MudSelect T="string" Label="Order" Value="@sortOrder" AnchorOrigin="Origin.BottomCenter" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true" ValueChanged="@(async (string v) =>
                                                                                                                                                                                  {
                                                                                                                                                                                      sortOrder = v;
                                                                                                                                                                                      await SearchBooks();
                                                                                                                                                                                  })">
                <MudSelectItem Value="@("asc")">Ascending</MudSelectItem>
                <MudSelectItem Value="@("desc")">Descending</MudSelectItem>
            </MudSelect>

            <MudDivider/>

            @* Author *@
            <MudAutocomplete T="AuthorDto" Label="Author" Value="@selectedAuthor" ValueChanged="@OnAuthorChanged"
                             SearchFunc="@SearchAuthors" ToStringFunc="@(e => e == null ? null : $"{e.Name}")"
                             Clearable="true" ResetValueOnEmptyText="true" CoerceText="true" CoerceValue="true"
                             AnchorOrigin="Origin.BottomCenter" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true"
                             AdornmentIcon="@Icons.Material.Filled.Search" AdornmentColor="Color.Primary"/>

            @* Category *@
            <MudAutocomplete T="CategoryDto" Label="Category" Value="@selectedCategory" ValueChanged="@OnCategoryChanged"
                             SearchFunc="@SearchCategories" ToStringFunc="@(e => e == null ? null : $"{e.Name}")"
                             Clearable="true" ResetValueOnEmptyText="true" CoerceText="true" CoerceValue="true"
                             AnchorOrigin="Origin.BottomCenter" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true"
                             AdornmentIcon="@Icons.Material.Filled.Search" AdornmentColor="Color.Primary"/>

            @* Publisher *@
            <MudAutocomplete T="PublisherDto" Label="Publisher" Value="@selectedPublisher" ValueChanged="@OnPublisherChanged"
                             SearchFunc="@SearchPublishers" ToStringFunc="@(e => e == null ? null : $"{e.Name}")"
                             Clearable="true" ResetValueOnEmptyText="true" CoerceText="true" CoerceValue="true"
                             AnchorOrigin="Origin.BottomCenter" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true"
                             AdornmentIcon="@Icons.Material.Filled.Search" AdornmentColor="Color.Primary"/>

            <MudDivider/>

            @* Price *@
            <MudText Typo="Typo.subtitle2">Price Range</MudText>
            <MudStack Row="true">
                <MudNumericField T="decimal?" Value="@minPrice" Label="Min" Variant="Variant.Outlined" Margin="Margin.Dense" HideSpinButtons="true" ValueChanged="@(async (decimal? v) =>
                                                                                                                                                                  {
                                                                                                                                                                      minPrice = v;
                                                                                                                                                                      await SearchBooks();
                                                                                                                                                                  })"/>
                <MudNumericField T="decimal?" Value="@maxPrice" Label="Max" Variant="Variant.Outlined" Margin="Margin.Dense" HideSpinButtons="true" ValueChanged="@(async (decimal? v) =>
                                                                                                                                                                  {
                                                                                                                                                                      maxPrice = v;
                                                                                                                                                                      await SearchBooks();
                                                                                                                                                                  })"/>
            </MudStack>

            @* On Sale *@
            <MudCheckBox T="bool" Value="@onSale" Label="On Sale Only" Color="Color.Error" Dense="true" ValueChanged="@(async (bool v) =>
                                                                                                                      {
                                                                                                                          onSale = v;
                                                                                                                          await SearchBooks();
                                                                                                                      })"/>

            <MudButton OnClick="ClearFilters" Variant="Variant.Text" Color="Color.Secondary" FullWidth="true" Class="mt-2" StartIcon="@Icons.Material.Filled.ClearAll">
                Reset Filters
            </MudButton>
        </MudStack>
    </MudPaper>
</MudItem>

@* Main Content *@
<MudItem xs="12" md="9">
    @* Search Bar *@
    <MudTextField @bind-Value="searchQuery"
                  Placeholder="Search by title, author, ISBN, or publisher..."
                  Variant="Variant.Outlined"
                  Adornment="Adornment.End"
                  AdornmentIcon="@Icons.Material.Filled.Search"
                  AdornmentColor="Color.Primary"
                  OnAdornmentClick="SearchBooks"
                  OnKeyUp="OnSearchKeyUp"
                  Clearable="true"
                  OnClearButtonClick="ClearSearch"
                  Immediate="true"
                  FullWidth="true"
                  UserAttributes="@(new Dictionary<string, object> { { "aria-label", "Search books" } })"
                  Style="margin-bottom: 24px;"/>

    @if (isLoading && pagedBooks == null)
    {
        <MudGrid>
            @for (int i = 0; i < 8; i++)
            {
                <MudItem xs="12" sm="6" md="4" lg="4">
                    <MudCard Elevation="2">
                        <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="200px"/>
                        <MudCardContent>
                            <MudSkeleton Width="80%"/>
                            <MudSkeleton Width="60%" Class="mt-2"/>
                            <MudSkeleton Width="40%" Class="mt-2"/>
                        </MudCardContent>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
    }
    else if (errorMessage != null)
    {
        <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Class="mb-4">
            <MudText>@errorMessage</MudText>
            <MudButton OnClick="RetryLoad" Color="Color.Surface" Variant="Variant.Text" StartIcon="@Icons.Material.Filled.Refresh" Class="mt-2">
                Retry
            </MudButton>
        </MudAlert>
    }
    else if (pagedBooks != null)
    {
        @* Results Info *@
        <MudStack Row="true" AlignItems="AlignItems.Center" Class="mb-3">
            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="results-count-badge">
                <MudText Typo="Typo.body2" Color="Color.Primary" Style="font-weight: 700; display: inline;">
                    @pagedBooks.Items.Count
                </MudText>
                &nbsp;of&nbsp;
                <MudText Typo="Typo.body2" Color="Color.Primary" Style="font-weight: 700; display: inline;">
                    @pagedBooks.TotalItemCount
                </MudText>
                &nbsp;books
                @if (!string.IsNullOrWhiteSpace(searchQuery))
                {
                    <MudChip T="string" Size="Size.Small" Color="Color.Primary" Variant="Variant.Filled" Class="ml-2">@searchQuery</MudChip>
                }
            </MudText>
            <MudSpacer/>
            @if (isFetching)
            {
                <MudProgressCircular Color="Color.Primary" Size="Size.Small" Indeterminate="true"/>
            }
        </MudStack>

        @if (isFetching)
        {
            <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4"/>
        }
        else
        {
            <div style="height: 4px;" class="mb-4"></div>
        }

        @* Book Grid *@
        <MudGrid Spacing="4" Class="mb-6">
            @* Optimistic books (being saved) *@
            @foreach (var optimisticBook in OptimisticService.GetOptimisticBooks())
            {
                <MudItem xs="12" sm="6" md="4" lg="3">
                    <MudCard Elevation="2" Class="optimistic-card" Style="height: 100%; border-radius: 16px; overflow: hidden;">
                        <div style="@($"background: linear-gradient({GetBookGradient(optimisticBook.Title, optimisticBook.AuthorNames)}); height: 240px; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; padding: 1.25rem 1rem; position: relative;")">
                            <span style="position:absolute;top:50%;left:50%;transform:translate(-50%,-55%);font-size:9rem;font-weight:900;color:rgba(255,255,255,0.1);line-height:1;user-select:none;">@(optimisticBook.Title?.FirstOrDefault().ToString().ToUpperInvariant())</span>
                            <MudText Style="color:#fff;font-weight:700;font-size:1.05rem;text-align:center;text-shadow:0 2px 10px rgba(0,0,0,0.4);line-height:1.3;z-index:1;" Class="mb-1 line-clamp-2">@optimisticBook.Title</MudText>
                            <MudText Style="color:rgba(255,255,255,0.75);font-size:0.78rem;text-align:center;z-index:1;">@optimisticBook.AuthorNames</MudText>
                        </div>
                        <MudCardContent Class="pa-3">
                            <MudChip T="string" Size="Size.Small" Color="Color.Info" Icon="@Icons.Material.Filled.CloudUpload" Variant="Variant.Filled">Saving...</MudChip>
                        </MudCardContent>
                    </MudCard>
                </MudItem>
            }

            @* Actual books from server *@
            @foreach (var book in pagedBooks.Items)
            {
                <MudItem xs="12" sm="6" md="4" lg="3">
                    <MudCard Elevation="2" Class="@($"book-card {(book.IsDeleted ? "deleted-book" : "")}")"
                             Style="height: 100%; border-radius: 16px; overflow: hidden; display: flex; flex-direction: column;">

                        @* ── Cover ─────────────────────────────────────── *@
                        <div class="book-cover" style="height: 240px; flex-shrink: 0;">
                            @* Hover overlay *@
                            <a href="@($"/book/{book.Id}")" class="book-view-overlay" aria-label="View @book.Title">
                                <MudPaper Elevation="4" Style="background: rgba(255,255,255,0.15); border-radius: 50px; padding: 0.5rem 1.5rem; backdrop-filter: blur(4px); border: 1px solid rgba(255,255,255,0.3);">
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                        <MudIcon Icon="@Icons.Material.Filled.Visibility" Style="color:#fff; font-size:1.1rem;"/>
                                        <MudText Style="color:#fff; font-weight:600; font-size:0.9rem;">View Details</MudText>
                                    </MudStack>
                                </MudPaper>
                            </a>

                            @* Favorite button *@
                            <AuthorizeView>
                                <Authorized>
                                    <MudIconButton Icon="@(book.IsFavorite ? UIConstants.Icons.Favorite : UIConstants.Icons.FavoriteBorder)"
                                                   Color="@(book.IsFavorite ? Color.Error : Color.Default)"
                                                   OnClick="@(() => ToggleFavorite(book))"
                                                   aria-label="@(book.IsFavorite ? "Remove from favorites" : "Add to favorites")"
                                                   Style="position: absolute; top: 10px; right: 10px; z-index: 10; background: rgba(0,0,0,0.4); border-radius: 50%; backdrop-filter: blur(4px);"
                                                   Size="Size.Small"/>
                                </Authorized>
                            </AuthorizeView>

                            @* Deleted badge *@
                            @if (book.IsDeleted)
                            {
                                <MudChip T="string" Color="Color.Error" Size="Size.Small"
                                         Style="position: absolute; top: 10px; left: 10px; z-index: 10;">
                                    DELETED
                                </MudChip>
                            }

                            @* Sale badge *@
                            @if (book.ActiveSale != null)
                            {
                                <div style="position: absolute; bottom: 10px; left: 10px; z-index: 6;">
                                    <BookSaleBadge Sale="@book.ActiveSale"/>
                                </div>
                            }

                            @if (!string.IsNullOrEmpty(book.CoverImageUrl))
                            {
                                <img src="@book.CoverImageUrl" alt="@book.Title"
                                     style="width: 100%; height: 240px; object-fit: cover; display: block;"/>
                            }
                            else
                            {
                                @* Generated gradient cover *@
                                <div class="book-cover-generated"
                                     style="@($"background: linear-gradient({GetBookGradient(book.Title, book.Authors.FirstOrDefault()?.Name)});")">
                                    <span class="book-cover-letter">@(book.Title.FirstOrDefault().ToString().ToUpperInvariant())</span>
                                    <MudText Style="color: #fff; font-weight: 700; font-size: 1.05rem; text-align: center; text-shadow: 0 2px 10px rgba(0,0,0,0.4); line-height: 1.3; z-index: 1;"
                                             Class="mb-1 line-clamp-2">
                                        @book.Title
                                    </MudText>
                                    <MudText Style="color: rgba(255,255,255,0.75); font-size: 0.78rem; text-align: center; z-index: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; max-width: 100%;">
                                        @string.Join(", ", book.Authors.Take(2).Select(a => a.Name))
                                    </MudText>
                                </div>
                            }
                        </div>

                        @* ── Content ───────────────────────────────────── *@
                        <MudCardContent Class="pa-3" Style="flex: 1; display: flex; flex-direction: column; gap: 4px;">
                            <MudText Typo="Typo.subtitle1"
                                     Style="font-weight: 600; line-height: 1.35; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden; min-height: 2.7rem;">
                                @book.Title
                            </MudText>
                            <MudText Typo="Typo.body2" Color="Color.Secondary"
                                     Style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 0.8rem;">
                                @string.Join(", ", book.Authors.Select(a => a.Name))
                            </MudText>

                            @if (book.Categories?.Count > 0)
                            {
                                <MudChip T="string" Size="Size.Small" Variant="Variant.Outlined" Color="Color.Primary"
                                         Style="margin: 0; height: 20px; font-size: 0.7rem; border-radius: 4px;">
                                    @book.Categories.First().Name
                                </MudChip>
                            }

                            <MudSpacer/>

                            @* Price row *@
                            <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween" Class="mt-1">
                                @if (book.ActiveSale != null && book.Prices != null && book.Prices.TryGetValue(CurrencyService.CurrentCurrency, out var originalPrice))
                                {
                                    var discountedPrice = book.ActiveSale.Value.CalculateDiscountedPrice(originalPrice);
                                    <MudStack Row="true" AlignItems="AlignItems.Baseline" Spacing="1">
                                        <MudText Typo="Typo.body2" Style="text-decoration: line-through; opacity: 0.5; font-size: 0.78rem;">
                                            @CurrencyService.FormatPrice(originalPrice)
                                        </MudText>
                                        <MudText Color="Color.Error" Style="font-weight: 700; font-size: 1.05rem;">
                                            @CurrencyService.FormatPrice(discountedPrice)
                                        </MudText>
                                    </MudStack>
                                }
                                else
                                {
                                    <MudText Color="Color.Primary" Style="font-weight: 700; font-size: 1.05rem;">
                                        @CurrencyService.FormatPrice(book.Prices)
                                    </MudText>
                                }

                                @if (book.RatingCount > 0)
                                {
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="0">
                                        <MudIcon Icon="@UIConstants.Icons.Star" Color="Color.Warning" Size="Size.Small"/>
                                        <MudText Typo="Typo.caption" Style="font-weight: 600;">
                                            @book.AverageRating.ToString("F1")
                                        </MudText>
                                    </MudStack>
                                }
                                else if (book.LikeCount > 0)
                                {
                                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="0">
                                        <MudIcon Icon="@UIConstants.Icons.Favorite" Color="Color.Error" Size="Size.Small"/>
                                        <MudText Typo="Typo.caption">@book.LikeCount</MudText>
                                    </MudStack>
                                }
                            </MudStack>
                        </MudCardContent>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>

        <MudScrollToTop>
            <MudFab Color="Color.Primary" StartIcon="@Icons.Material.Filled.ArrowUpward" aria-label="Back to top"/>
        </MudScrollToTop>

        @* Pagination *@
        @if (pagedBooks.PageCount > 1)
        {
            <MudPaper Elevation="0" Class="d-flex justify-center pa-4">
                <MudPagination Count="@((int)pagedBooks.PageCount)"
                               Selected="@currentPage"
                               SelectedChanged="LoadPage"
                               Color="Color.Primary"
                               Variant="Variant.Filled"
                               ShowFirstButton="true"
                               ShowLastButton="true"/>
            </MudPaper>
        }

        @* Empty State *@
        @if (pagedBooks.Items.Count == 0)
        {
            <MudPaper Elevation="0" Class="pa-8 text-center">
                <MudIcon Icon="@Icons.Material.Filled.SearchOff" Size="Size.Large" Color="Color.Secondary" Style="font-size: 6rem;"/>
                <MudText Typo="Typo.h5" Class="mt-4 mb-2">No books found</MudText>
                <MudText Typo="Typo.body1" Color="Color.Secondary">
                    Try adjusting your search terms or filters
                </MudText>
                <MudButton OnClick="ClearFilters" Variant="Variant.Text" Color="Color.Primary" Class="mt-2">
                    Clear All Filters
                </MudButton>
            </MudPaper>
        }
    }
</MudItem>
</MudGrid>
</MudContainer>

@code {
    private ReactiveQuery<PagedListDto<BookDto>>? bookQuery;
    private PagedListDto<BookDto>? pagedBooks => bookQuery?.Data;
    private bool isLoading => bookQuery?.IsLoading ?? true;
    private bool isFetching => bookQuery?.IsFetching ?? false;
    private string? errorMessage => bookQuery?.Error;

    private string searchQuery = string.Empty;
    private int currentPage = 1;

    // Filters
    private AuthorDto? selectedAuthor;
    private CategoryDto? selectedCategory;
    private PublisherDto? selectedPublisher;

    private bool onSale;
    private decimal? minPrice;
    private decimal? maxPrice;
    private string sortBy = "title";
    private string sortOrder = "asc";

    // Filter Data
    private List<AuthorDto> authors = new();
    private List<CategoryDto> categories = new();
    private List<PublisherDto> publishers = new();

    private System.Threading.Timer? debounceTimer;
    private System.Threading.Timer? cleanupTimer;

    [Inject] private ILogger<Home> Logger { get; set; } = default!;
    [Inject] private QueryInvalidationService InvalidationService { get; set; } = default!;

    [CascadingParameter] private Task<AuthenticationState> AuthStateTask { get; set; } = default!;
    private System.Security.Claims.ClaimsPrincipal? user;
    private readonly CancellationTokenSource _cts = new();
    private bool _disposed;

    protected override async Task OnInitializedAsync()
    {
        // Initialize Tenant FIRST
        await TenantService.InitializeAsync();

        // Subscribe to optimistic update changes
        OptimisticService.OnBooksChanged += HandleOptimisticBooksChanged;

        // Start SSE listening
        EventsService.StartListening();
        EventsService.OnNotificationReceived += HandleNotification;

        // Initialize ReactiveQuery
        bookQuery = new ReactiveQuery<PagedListDto<BookDto>>(
            queryFn: ct => FetchBooksAsync(ct),
            eventsService: EventsService,
            invalidationService: InvalidationService,
            queryKeys: new[] { "Books", "Authors", "Publishers" },
            onStateChanged: () => InvokeAsync(StateHasChanged),
            logger: Logger
        );

        // Initial load
        await bookQuery.LoadAsync(cancellationToken: _cts.Token);

        // Start cleanup timer for stale optimistic books
        StartCleanupTimer();

        // Subscribe to currency changes
        CurrencyService.OnCurrencyChanged += HandleCurrencyChanged;

        // Subscribe to tenant changes (and reload data)
        TenantService.OnChange += HandleTenantChanged;

        await LoadFiltersAsync();
    }

    private void HandleCurrencyChanged()
    {
        if (_disposed) return;
        // Reload books when currency changes
        _ = bookQuery?.LoadAsync(cancellationToken: _cts.Token);
        StateHasChanged();
    }

    private async Task LoadFiltersAsync()
    {
        try
        {
            var authorsTask = AuthorsClient.GetAuthorsAsync(1, 1000); // Fetch more for autocomplete
            var categoriesTask = CategoriesClient.GetCategoriesAsync(1, 1000, "name", "asc");
            var publishersTask = PublishersClient.GetPublishersAsync(1, 1000);

            await Task.WhenAll(authorsTask, categoriesTask, publishersTask);

            authors = (await authorsTask).Items.ToList();
            categories = (await categoriesTask).Items.ToList();
            publishers = (await publishersTask).Items.ToList();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load filters");
        }
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        return Task.CompletedTask;
    }

    private void HandleTenantChanged()
    {
        if (_disposed) return;
        // Reload books when tenant changes
        _ = bookQuery?.LoadAsync(cancellationToken: _cts.Token);
        StateHasChanged();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_disposed) return;
        var authState = await AuthStateTask;
        var newUser = authState.User;

        if (user == null || newUser.Identity?.Name != user.Identity?.Name || newUser.Identity?.IsAuthenticated != user.Identity?.IsAuthenticated)
        {
            user = newUser;
            if (user.Identity?.IsAuthenticated == true && bookQuery != null)
            {
                await bookQuery.LoadAsync(silent: true, cancellationToken: _cts.Token);
            }
        }
    }

    private async Task<IEnumerable<AuthorDto>> SearchAuthors(string value, CancellationToken token)
    {
        if (string.IsNullOrEmpty(value))
            return authors;
        return authors.Where(x => x.Name?.Contains(value, StringComparison.InvariantCultureIgnoreCase) ?? false);
    }

    private async Task<IEnumerable<CategoryDto>> SearchCategories(string value, CancellationToken token)
    {
        if (string.IsNullOrEmpty(value))
            return categories;
        return categories.Where(x => x.Name?.Contains(value, StringComparison.InvariantCultureIgnoreCase) ?? false);
    }

    private async Task<IEnumerable<PublisherDto>> SearchPublishers(string value, CancellationToken token)
    {
        if (string.IsNullOrEmpty(value))
            return publishers;
        return publishers.Where(x => x.Name?.Contains(value, StringComparison.InvariantCultureIgnoreCase) ?? false);
    }

    private async Task OnAuthorChanged(AuthorDto? author)
    {
        selectedAuthor = author;
        await SearchBooks();
    }

    private async Task OnCategoryChanged(CategoryDto? category)
    {
        selectedCategory = category;
        await SearchBooks();
    }

    private async Task OnPublisherChanged(PublisherDto? publisher)
    {
        selectedPublisher = publisher;
        await SearchBooks();
    }

    private async Task<PagedListDto<BookDto>> FetchBooksAsync(CancellationToken cancellationToken)
    {
        var request = new BookSearchRequest
        {
            Page = currentPage,
            PageSize = UIConstants.DefaultPageSize,
            Search = string.IsNullOrWhiteSpace(searchQuery) ? string.Empty : searchQuery,
            AuthorId = selectedAuthor?.Id,
            CategoryId = selectedCategory?.Id,
            PublisherId = selectedPublisher?.Id,
            OnSale = onSale ? true : null,
            MinPrice = minPrice,
            MaxPrice = maxPrice,
            Currency = CurrencyService.CurrentCurrency,
            SortBy = sortBy,
            SortOrder = sortOrder
        };

        return await BooksClient.GetBooksAsync(
            request, cancellationToken);
    }

    private void HandleNotification(BookStore.Shared.Notifications.IDomainEventNotification notification)
    {
        try
        {
            // Side effect: Confirm optimistic book if created
            if (notification is BookStore.Shared.Notifications.BookCreatedNotification bookCreated)
            {
                OptimisticService.ConfirmBook(bookCreated.EntityId);
            }
        }
        catch (OperationCanceledException)
        {
            // Expected during navigation
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Error processing notification in Home.");
        }
    }

    private void OnSearchKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            _ = SearchBooks();
            return;
        }

        // Debounce search
        debounceTimer?.Dispose();
        debounceTimer = new System.Threading.Timer(async _ => { await InvokeAsync(SearchBooks); }, null, UIConstants.DebounceDelay, Timeout.Infinite);
    }

    private async Task SearchBooks()
    {
        if (_disposed) return;
        currentPage = 1;
        if (bookQuery != null)
        {
            await bookQuery.LoadAsync(silent: true);
        }
    }

    private void ClearSearch()
    {
        searchQuery = string.Empty;
        _ = SearchBooks();
    }

    private void ClearFilters()
    {
        selectedAuthor = null;
        selectedCategory = null;
        selectedPublisher = null;
        minPrice = null;
        maxPrice = null;
        onSale = false;
        searchQuery = string.Empty;
        sortBy = "title";
        sortOrder = "asc";

        _ = SearchBooks();
    }

    private async Task LoadPage(int page)
    {
        if (_disposed) return;
        currentPage = page;
        if (bookQuery != null)
        {
            await bookQuery.LoadAsync(silent: true);
        }
    }

    private async Task ToggleFavorite(BookDto book)
    {
        await CatalogService.ToggleFavoriteAsync(book,
            setOptimistic: (newState) => bookQuery?.MutateData(currentList =>
            {
                var items = currentList.Items.ToList();
                var index = items.FindIndex(b => b.Id == book.Id);
                if (index != -1)
                {
                    items[index] = items[index] with
                    {
                        IsFavorite = newState,
                        LikeCount = newState ? items[index].LikeCount + 1 : items[index].LikeCount - 1
                    };
                }

                return new PagedListDto<BookDto>(
                    items,
                    currentList.PageNumber,
                    currentList.PageSize,
                    currentList.TotalItemCount
                );
            }),
            setRollback: (oldState) => bookQuery?.MutateData(currentList =>
            {
                var items = currentList.Items.ToList();
                var index = items.FindIndex(b => b.Id == book.Id);
                if (index != -1)
                {
                    items[index] = items[index] with
                    {
                        IsFavorite = oldState,
                        LikeCount = oldState ? items[index].LikeCount + 1 : items[index].LikeCount - 1
                    };
                }

                return new PagedListDto<BookDto>(
                    items,
                    currentList.PageNumber,
                    currentList.PageSize,
                    currentList.TotalItemCount
                );
            }),
            cancellationToken: _cts.Token);
    }

    private async Task RetryLoad()
    {
        if (_disposed) return;
        if (bookQuery != null)
        {
            await bookQuery.LoadAsync(cancellationToken: _cts.Token);
        }
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        OptimisticService.OnBooksChanged -= HandleOptimisticBooksChanged;
        EventsService.OnNotificationReceived -= HandleNotification;
        CurrencyService.OnCurrencyChanged -= HandleCurrencyChanged;
        TenantService.OnChange -= HandleTenantChanged;

        _cts.Cancel();
        _cts.Dispose();
        bookQuery?.Dispose();
        debounceTimer?.Dispose();
    }

    private void HandleOptimisticBooksChanged()
    {
        // Refresh UI when optimistic books change
        InvokeAsync(StateHasChanged);
    }

    private void StartCleanupTimer()
    {
        // Clean up stale optimistic books every 5 seconds
        cleanupTimer = new System.Threading.Timer(_ => { OptimisticService.CleanupStaleBooks(); }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
    }

    /// <summary>Returns a deterministic CSS gradient string based on hashed book title + author.</summary>
    private static string GetBookGradient(string? title, string? author = null)
    {
        var key = (title ?? "") + (author ?? "");
        var hash = (uint)Math.Abs(key.GetHashCode());
        ReadOnlySpan<string> palettes =
        [
            "135deg, #667eea 0%, #764ba2 100%",
            "135deg, #f093fb 0%, #f5576c 100%",
            "135deg, #4facfe 0%, #00f2fe 100%",
            "135deg, #43e97b 0%, #38f9d7 100%",
            "160deg, #fa709a 0%, #fee140 100%",
            "135deg, #a18cd1 0%, #fbc2eb 100%",
            "160deg, #fd7043 0%, #cc2b5e 100%",
            "135deg, #11998e 0%, #38ef7d 100%",
            "135deg, #ee0979 0%, #ff6a00 100%",
            "135deg, #0575e6 0%, #021b79 100%",
            "160deg, #f7971e 0%, #ffd200 100%",
            "135deg, #373b44 0%, #4286f4 100%",
            "160deg, #c94b4b 0%, #4b134f 100%",
            "135deg, #2c3e50 0%, #3498db 100%",
            "160deg, #134e5e 0%, #71b280 100%",
            "135deg, #1a1a2e 0%, #0f3460 100%",
        ];
        return palettes[(int)(hash % (uint)palettes.Length)];
    }


}
