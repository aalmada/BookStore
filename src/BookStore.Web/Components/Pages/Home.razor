@page "/"
@using BookStore.Client
@using ClientModels = BookStore.Client
@using BookStore.Shared.Models
@using BookStore.Web.Services
@using Microsoft.AspNetCore.Components.Authorization
@using BookStore.Web.Components.Catalog
@inject IBooksClient BooksClient
@inject BookStoreEventsService EventsService
@inject OptimisticUpdateService OptimisticService
@inject AuthenticationStateProvider AuthStateProvider
@inject ISnackbar Snackbar
@inject CatalogService CatalogService
@implements IDisposable
@rendermode InteractiveServer

@inject IAuthorsClient AuthorsClient
@inject ICategoriesClient CategoriesClient
@inject IPublishersClient PublishersClient

@inject TenantService TenantService
@inject CurrencyService CurrencyService
@using BookStore.Web.Infrastructure

<PageTitle>@TenantService.CurrentTenantName - Discover Your Next Great Read</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge">
@* ─── Hero Section ──────────────────────────────────────────────────── *@
<MudPaper Elevation="0" Class="mb-6 hero-banner"
          Style="@((!string.IsNullOrEmpty(TenantService.CurrentTenantHeroBannerUrl)
              ? $"background: url('{TenantService.CurrentTenantHeroBannerUrl}') center/cover no-repeat"
              : $"background: linear-gradient(135deg, {TenantService.CurrentTenantPrimaryColor} 0%, {TenantService.CurrentTenantSecondaryColor} 100%)")
              + "; border-radius: 20px; overflow: hidden; min-height: 320px; position: relative; display: flex; align-items: flex-end;")">
    @* overlay for readability over images *@
    <div class="hero-overlay" style="position: absolute; inset: 0; background: linear-gradient(to top, rgba(0,0,0,0.65) 0%, rgba(0,0,0,0.1) 60%); border-radius: 20px;"></div>
    <div style="position: relative; z-index: 1; padding: 2.5rem;">
        <MudText Typo="Typo.h3" Style="color: #fff; font-weight: 700; letter-spacing: -0.03em; text-shadow: 0 2px 12px rgba(0,0,0,0.35);" Class="mb-2">
            @TenantService.CurrentTenantName
        </MudText>
        <MudText Typo="Typo.h6" Style="color: rgba(255,255,255,0.88); font-weight: 400;" Class="mb-4">
            @TenantService.CurrentTenantTagline
        </MudText>
        <MudButton Variant="Variant.Filled" Color="Color.Surface" Size="Size.Large"
                   StartIcon="@Icons.Material.Filled.MenuBook"
                   Style="font-weight: 600; border-radius: 50px; padding: 0 1.75rem;">
            Browse Books
        </MudButton>
    </div>
</MudPaper>

<MudGrid Spacing="6">
@* Filters Sidebar *@
<MudItem xs="12" md="3">
    <MudPaper Class="pa-4 mb-6" Elevation="2" Style="border-radius: 12px; position: sticky; top: 20px;">
        <MudText Typo="Typo.h6" Class="mb-4">
            <MudIcon Icon="@Icons.Material.Filled.FilterList" Class="mr-2"/> Filters
        </MudText>

        <MudStack Spacing="3">
            @* Sort *@
            <MudSelect T="string" Label="Sort By" Value="@sortBy" AnchorOrigin="Origin.BottomCenter" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true" ValueChanged="@(async (string v) =>
                                                                                                                                                                                 {
                                                                                                                                                                                     sortBy = v;
                                                                                                                                                                                     await SearchBooks();
                                                                                                                                                                                 })">
                <MudSelectItem Value="@("title")">Title</MudSelectItem>
                <MudSelectItem Value="@("date")">Date Added</MudSelectItem>
                <MudSelectItem Value="@("publisher")">Publisher</MudSelectItem>
            </MudSelect>

            <MudSelect T="string" Label="Order" Value="@sortOrder" AnchorOrigin="Origin.BottomCenter" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true" ValueChanged="@(async (string v) =>
                                                                                                                                                                                  {
                                                                                                                                                                                      sortOrder = v;
                                                                                                                                                                                      await SearchBooks();
                                                                                                                                                                                  })">
                <MudSelectItem Value="@("asc")">Ascending</MudSelectItem>
                <MudSelectItem Value="@("desc")">Descending</MudSelectItem>
            </MudSelect>

            <MudDivider/>

            @* Author *@
            <MudAutocomplete T="AuthorDto" Label="Author" Value="@selectedAuthor" ValueChanged="@OnAuthorChanged"
                             SearchFunc="@SearchAuthors" ToStringFunc="@(e => e == null ? null : $"{e.Name}")"
                             Clearable="true" ResetValueOnEmptyText="true" CoerceText="true" CoerceValue="true"
                             AnchorOrigin="Origin.BottomCenter" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true"
                             AdornmentIcon="@Icons.Material.Filled.Search" AdornmentColor="Color.Primary"/>

            @* Category *@
            <MudAutocomplete T="CategoryDto" Label="Category" Value="@selectedCategory" ValueChanged="@OnCategoryChanged"
                             SearchFunc="@SearchCategories" ToStringFunc="@(e => e == null ? null : $"{e.Name}")"
                             Clearable="true" ResetValueOnEmptyText="true" CoerceText="true" CoerceValue="true"
                             AnchorOrigin="Origin.BottomCenter" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true"
                             AdornmentIcon="@Icons.Material.Filled.Search" AdornmentColor="Color.Primary"/>

            @* Publisher *@
            <MudAutocomplete T="PublisherDto" Label="Publisher" Value="@selectedPublisher" ValueChanged="@OnPublisherChanged"
                             SearchFunc="@SearchPublishers" ToStringFunc="@(e => e == null ? null : $"{e.Name}")"
                             Clearable="true" ResetValueOnEmptyText="true" CoerceText="true" CoerceValue="true"
                             AnchorOrigin="Origin.BottomCenter" Variant="Variant.Outlined" Margin="Margin.Dense" Dense="true"
                             AdornmentIcon="@Icons.Material.Filled.Search" AdornmentColor="Color.Primary"/>

            <MudDivider/>

            @* Price *@
            <MudText Typo="Typo.subtitle2">Price Range</MudText>
            <MudStack Row="true">
                <MudNumericField T="decimal?" Value="@minPrice" Label="Min" Variant="Variant.Outlined" Margin="Margin.Dense" HideSpinButtons="true" ValueChanged="@(async (decimal? v) =>
                                                                                                                                                                  {
                                                                                                                                                                      minPrice = v;
                                                                                                                                                                      await SearchBooks();
                                                                                                                                                                  })"/>
                <MudNumericField T="decimal?" Value="@maxPrice" Label="Max" Variant="Variant.Outlined" Margin="Margin.Dense" HideSpinButtons="true" ValueChanged="@(async (decimal? v) =>
                                                                                                                                                                  {
                                                                                                                                                                      maxPrice = v;
                                                                                                                                                                      await SearchBooks();
                                                                                                                                                                  })"/>
            </MudStack>

            @* On Sale *@
            <MudCheckBox T="bool" Value="@onSale" Label="On Sale Only" Color="Color.Error" Dense="true" ValueChanged="@(async (bool v) =>
                                                                                                                      {
                                                                                                                          onSale = v;
                                                                                                                          await SearchBooks();
                                                                                                                      })"/>

            <MudButton OnClick="ClearFilters" Variant="Variant.Text" Color="Color.Secondary" FullWidth="true" Class="mt-2" StartIcon="@Icons.Material.Filled.ClearAll">
                Reset Filters
            </MudButton>
        </MudStack>
    </MudPaper>
</MudItem>

@* Main Content *@
<MudItem xs="12" md="9">
    @* Search Bar *@
    <MudPaper Elevation="2" Class="pa-4 mb-6" Style="border-radius: 12px;">
        <MudTextField @bind-Value="searchQuery"
                      Label="Search books"
                      Placeholder="Search by title, author, ISBN, or publisher..."
                      Variant="Variant.Outlined"
                      Adornment="Adornment.End"
                      AdornmentIcon="@Icons.Material.Filled.Search"
                      AdornmentColor="Color.Primary"
                      OnAdornmentClick="SearchBooks"
                      OnKeyUp="OnSearchKeyUp"
                      Clearable="true"
                      OnClearButtonClick="ClearSearch"
                      Immediate="true"
                      FullWidth="true"
                      UserAttributes="@(new Dictionary<string, object> { { "aria-label", "Search books" } })"
                      Class="mud-text-field-large"/>
    </MudPaper>

    @if (isLoading && pagedBooks == null)
    {
        <MudGrid>
            @for (int i = 0; i < 8; i++)
            {
                <MudItem xs="12" sm="6" md="4" lg="4">
                    <MudCard Elevation="2">
                        <MudSkeleton SkeletonType="SkeletonType.Rectangle" Height="200px"/>
                        <MudCardContent>
                            <MudSkeleton Width="80%"/>
                            <MudSkeleton Width="60%" Class="mt-2"/>
                            <MudSkeleton Width="40%" Class="mt-2"/>
                        </MudCardContent>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>
    }
    else if (errorMessage != null)
    {
        <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Class="mb-4">
            <MudText>@errorMessage</MudText>
            <MudButton OnClick="RetryLoad" Color="Color.Surface" Variant="Variant.Text" StartIcon="@Icons.Material.Filled.Refresh" Class="mt-2">
                Retry
            </MudButton>
        </MudAlert>
    }
    else if (pagedBooks != null)
    {
        @* Results Info *@
        <MudStack Row="true" AlignItems="AlignItems.Center" Class="mb-4">
            <MudText Typo="Typo.body2" Color="Color.Secondary">
                Showing @pagedBooks.Items.Count of @pagedBooks.TotalItemCount books
                @if (!string.IsNullOrWhiteSpace(searchQuery))
                {
                    <MudChip T="string" Size="Size.Small" Color="Color.Primary" Class="ml-2">@searchQuery</MudChip>
                }
            </MudText>
            <MudSpacer/>
            @if (isFetching)
            {
                <MudProgressCircular Color="Color.Primary" Size="Size.Small" Indeterminate="true"/>
            }
        </MudStack>

        @if (isFetching)
        {
            <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="mb-4"/>
        }
        else
        {
            <div style="height: 4px;" class="mb-4"></div>
        }

        @* Book Grid *@
        <MudGrid Spacing="4" Class="mb-6">
            @* Optimistic books (being saved) *@
            @foreach (var optimisticBook in OptimisticService.GetOptimisticBooks())
            {
                <MudItem xs="12" sm="6" md="4" lg="4">
                    <MudCard Elevation="4" Class="optimistic-card" Style="height: 100%; border-radius: 12px;">
                        <MudPaper Elevation="0" Height="200px" Style="background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); display: flex; align-items: center; justify-content: center;">
                            <MudIcon Icon="@Icons.Material.Filled.MenuBook" Size="Size.Large" Color="Color.Secondary" Style="font-size: 4rem;"/>
                        </MudPaper>
                        <MudCardContent>
                            <MudText Typo="Typo.h6" Class="mb-2">@optimisticBook.Title</MudText>
                            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-1">
                                <MudIcon Icon="@UIConstants.Icons.Author" Size="Size.Small" Class="mr-1"/> @optimisticBook.AuthorNames
                            </MudText>
                            @if (!string.IsNullOrWhiteSpace(optimisticBook.PublisherName))
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary">
                                    <MudIcon Icon="@UIConstants.Icons.Publisher" Size="Size.Small" Class="mr-1"/> @optimisticBook.PublisherName
                                </MudText>
                            }
                        </MudCardContent>
                        <MudCardActions>
                            <MudChip T="string" Size="Size.Small" Color="Color.Info" Icon="@Icons.Material.Filled.CloudUpload">Saving...</MudChip>
                        </MudCardActions>
                    </MudCard>
                </MudItem>
            }

            @* Actual books from server *@
            @foreach (var book in pagedBooks.Items)
            {
                <MudItem xs="12" sm="6" md="4" lg="4">
                    <MudCard Elevation="1" Class="@($"book-card {(book.IsDeleted ? "deleted-book" : "")}")" Style="height: 100%; transition: all 0.25s ease; position: relative; overflow: hidden;">
                        @* Heart Overlay *@
                        <AuthorizeView>
                            <Authorized>
                                <MudIconButton Icon="@(book.IsFavorite ? UIConstants.Icons.Favorite : UIConstants.Icons.FavoriteBorder)"
                                               Color="@(book.IsFavorite ? Color.Error : Color.Default)"
                                               OnClick="@(() => ToggleFavorite(book))"
                                               Class="favorite-overlay"
                                               aria-label="@(book.IsFavorite ? "Remove from favorites" : "Add to favorites")"
                                               Style="position: absolute; top: 12px; right: 12px; z-index: 10; background-color: rgba(255,255,255,0.8); backdrop-filter: blur(4px);"
                                               Size="Size.Medium"/>
                            </Authorized>
                        </AuthorizeView>

                        @* Deleted Overlay/Badge *@
                        @if (book.IsDeleted)
                        {
                            <MudChip T="string" Color="Color.Error" Size="Size.Small" Class="deleted-badge"
                                     Style="position: absolute; top: 12px; left: 12px; z-index: 10;">
                                DELETED
                            </MudChip>
                        }

                        @if (!string.IsNullOrEmpty(book.CoverImageUrl))
                        {
                            <MudImage Src="@book.CoverImageUrl" Alt="@book.Title" ObjectFit="@ObjectFit.Cover" Height="200" Fluid="true" Class="rounded-lg"/>
                        }
                        else
                        {
                            <MudPaper Elevation="0" Height="200px" Style="background: var(--mud-palette-primary); color: var(--mud-palette-primary-text); display: flex; align-items: center; justify-content: center;">
                                <MudIcon Icon="@UIConstants.Icons.Book" Size="Size.Large" Color="Color.Inherit" Style="font-size: 4rem;"/>
                            </MudPaper>
                        }
                        <MudCardContent>
                            <MudText Typo="Typo.h6" Class="mb-2" Style="min-height: 3rem; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">
                                @book.Title
                            </MudText>
                            <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-1">
                                <MudIcon Icon="@UIConstants.Icons.Author" Size="Size.Small" Class="mr-1"/> @string.Join(", ", book.Authors.Select(a => a.Name))
                            </MudText>
                            @if (book.Categories?.Count > 0)
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-1">
                                    <MudIcon Icon="@UIConstants.Icons.Category" Size="Size.Small" Class="mr-1"/>
                                    @foreach (var category in book.Categories)
                                    {
                                        <MudChip T="string" Size="Size.Small" Variant="Variant.Text" Color="Color.Primary" Class="mr-1">@category.Name</MudChip>
                                    }
                                </MudText>
                            }
                            @if (book.Publisher != null)
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-1">
                                    <MudIcon Icon="@UIConstants.Icons.Publisher" Size="Size.Small" Class="mr-1"/> @book.Publisher.Name
                                </MudText>
                            }
                            @if (book.PublicationDate.HasValue)
                            {
                                <MudText Typo="Typo.body2" Color="Color.Secondary">
                                    <MudIcon Icon="@Icons.Material.Filled.CalendarToday" Size="Size.Small"/> @book.PublicationDate.Value.Year
                                </MudText>
                            }
                            @if (book.ActiveSale != null && book.Prices != null && book.Prices.TryGetValue(CurrencyService.CurrentCurrency, out var originalPrice))
                            {
                                var discountedPrice = book.ActiveSale.Value.CalculateDiscountedPrice(originalPrice);
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mt-2">
                                    <MudText Typo="Typo.body2" Style="text-decoration: line-through; color: var(--mud-palette-text-secondary); opacity: 0.7;">
                                        @CurrencyService.FormatPrice(originalPrice)
                                    </MudText>
                                    <MudText Typo="Typo.h6" Color="Color.Error" Class="font-weight-bold">
                                        @CurrencyService.FormatPrice(discountedPrice)
                                    </MudText>
                                    <BookSaleBadge Sale="@book.ActiveSale"/>
                                </MudStack>
                            }
                            else
                            {
                                <MudText Typo="Typo.h6" Color="Color.Primary" Class="mt-2 font-weight-bold">
                                    @CurrencyService.FormatPrice(book.Prices)
                                </MudText>
                            }
                        </MudCardContent>
                        <MudCardActions>
                            <MudButton Href="@($"/book/{book.Id}")" Variant="Variant.Text" Color="Color.Primary" FullWidth="true" StartIcon="@Icons.Material.Filled.Visibility">
                                View Details
                            </MudButton>
                            <MudSpacer/>
                            @if (book.RatingCount > 0)
                            {
                                <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="1">
                                    <MudIcon Icon="@UIConstants.Icons.Star" Color="Color.Warning" Size="Size.Small"/>
                                    <MudText Typo="Typo.caption">@book.AverageRating.ToString("F1")</MudText>
                                </MudStack>
                            }
                            <MudChip T="string" Size="Size.Small" Icon="@UIConstants.Icons.Favorite" Color="Color.Error" Variant="Variant.Text">
                                @book.LikeCount
                            </MudChip>
                        </MudCardActions>
                    </MudCard>
                </MudItem>
            }
        </MudGrid>

        <MudScrollToTop>
            <MudFab Color="Color.Primary" StartIcon="@Icons.Material.Filled.ArrowUpward" aria-label="Back to top"/>
        </MudScrollToTop>

        @* Pagination *@
        @if (pagedBooks.PageCount > 1)
        {
            <MudPaper Elevation="0" Class="d-flex justify-center pa-4">
                <MudPagination Count="@((int)pagedBooks.PageCount)"
                               Selected="@currentPage"
                               SelectedChanged="LoadPage"
                               Color="Color.Primary"
                               Variant="Variant.Filled"
                               ShowFirstButton="true"
                               ShowLastButton="true"/>
            </MudPaper>
        }

        @* Empty State *@
        @if (pagedBooks.Items.Count == 0)
        {
            <MudPaper Elevation="0" Class="pa-8 text-center">
                <MudIcon Icon="@Icons.Material.Filled.SearchOff" Size="Size.Large" Color="Color.Secondary" Style="font-size: 6rem;"/>
                <MudText Typo="Typo.h5" Class="mt-4 mb-2">No books found</MudText>
                <MudText Typo="Typo.body1" Color="Color.Secondary">
                    Try adjusting your search terms or filters
                </MudText>
                <MudButton OnClick="ClearFilters" Variant="Variant.Text" Color="Color.Primary" Class="mt-2">
                    Clear All Filters
                </MudButton>
            </MudPaper>
        }
    }
</MudItem>
</MudGrid>
</MudContainer>

@code {
    private ReactiveQuery<PagedListDto<BookDto>>? bookQuery;
    private PagedListDto<BookDto>? pagedBooks => bookQuery?.Data;
    private bool isLoading => bookQuery?.IsLoading ?? true;
    private bool isFetching => bookQuery?.IsFetching ?? false;
    private string? errorMessage => bookQuery?.Error;

    private string searchQuery = string.Empty;
    private int currentPage = 1;

    // Filters
    private AuthorDto? selectedAuthor;
    private CategoryDto? selectedCategory;
    private PublisherDto? selectedPublisher;

    private bool onSale;
    private decimal? minPrice;
    private decimal? maxPrice;
    private string sortBy = "title";
    private string sortOrder = "asc";

    // Filter Data
    private List<AuthorDto> authors = new();
    private List<CategoryDto> categories = new();
    private List<PublisherDto> publishers = new();

    private System.Threading.Timer? debounceTimer;
    private System.Threading.Timer? cleanupTimer;

    [Inject] private ILogger<Home> Logger { get; set; } = default!;
    [Inject] private QueryInvalidationService InvalidationService { get; set; } = default!;

    [CascadingParameter] private Task<AuthenticationState> AuthStateTask { get; set; } = default!;
    private System.Security.Claims.ClaimsPrincipal? user;
    private readonly CancellationTokenSource _cts = new();
    private bool _disposed;

    protected override async Task OnInitializedAsync()
    {
        // Initialize Tenant FIRST
        await TenantService.InitializeAsync();

        // Subscribe to optimistic update changes
        OptimisticService.OnBooksChanged += HandleOptimisticBooksChanged;

        // Start SSE listening
        EventsService.StartListening();
        EventsService.OnNotificationReceived += HandleNotification;

        // Initialize ReactiveQuery
        bookQuery = new ReactiveQuery<PagedListDto<BookDto>>(
            queryFn: ct => FetchBooksAsync(ct),
            eventsService: EventsService,
            invalidationService: InvalidationService,
            queryKeys: new[] { "Books", "Authors", "Publishers" },
            onStateChanged: () => InvokeAsync(StateHasChanged),
            logger: Logger
        );

        // Initial load
        await bookQuery.LoadAsync(cancellationToken: _cts.Token);

        // Start cleanup timer for stale optimistic books
        StartCleanupTimer();

        // Subscribe to currency changes
        CurrencyService.OnCurrencyChanged += HandleCurrencyChanged;

        // Subscribe to tenant changes (and reload data)
        TenantService.OnChange += HandleTenantChanged;

        await LoadFiltersAsync();
    }

    private void HandleCurrencyChanged()
    {
        if (_disposed) return;
        // Reload books when currency changes
        _ = bookQuery?.LoadAsync(cancellationToken: _cts.Token);
        StateHasChanged();
    }

    private async Task LoadFiltersAsync()
    {
        try
        {
            var authorsTask = AuthorsClient.GetAuthorsAsync(1, 1000); // Fetch more for autocomplete
            var categoriesTask = CategoriesClient.GetCategoriesAsync(1, 1000, "name", "asc");
            var publishersTask = PublishersClient.GetPublishersAsync(1, 1000);

            await Task.WhenAll(authorsTask, categoriesTask, publishersTask);

            authors = (await authorsTask).Items.ToList();
            categories = (await categoriesTask).Items.ToList();
            publishers = (await publishersTask).Items.ToList();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load filters");
        }
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        return Task.CompletedTask;
    }

    private void HandleTenantChanged()
    {
        if (_disposed) return;
        // Reload books when tenant changes
        _ = bookQuery?.LoadAsync(cancellationToken: _cts.Token);
        StateHasChanged();
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_disposed) return;
        var authState = await AuthStateTask;
        var newUser = authState.User;

        if (user == null || newUser.Identity?.Name != user.Identity?.Name || newUser.Identity?.IsAuthenticated != user.Identity?.IsAuthenticated)
        {
            user = newUser;
            if (user.Identity?.IsAuthenticated == true && bookQuery != null)
            {
                await bookQuery.LoadAsync(silent: true, cancellationToken: _cts.Token);
            }
        }
    }

    private async Task<IEnumerable<AuthorDto>> SearchAuthors(string value, CancellationToken token)
    {
        if (string.IsNullOrEmpty(value))
            return authors;
        return authors.Where(x => x.Name?.Contains(value, StringComparison.InvariantCultureIgnoreCase) ?? false);
    }

    private async Task<IEnumerable<CategoryDto>> SearchCategories(string value, CancellationToken token)
    {
        if (string.IsNullOrEmpty(value))
            return categories;
        return categories.Where(x => x.Name?.Contains(value, StringComparison.InvariantCultureIgnoreCase) ?? false);
    }

    private async Task<IEnumerable<PublisherDto>> SearchPublishers(string value, CancellationToken token)
    {
        if (string.IsNullOrEmpty(value))
            return publishers;
        return publishers.Where(x => x.Name?.Contains(value, StringComparison.InvariantCultureIgnoreCase) ?? false);
    }

    private async Task OnAuthorChanged(AuthorDto? author)
    {
        selectedAuthor = author;
        await SearchBooks();
    }

    private async Task OnCategoryChanged(CategoryDto? category)
    {
        selectedCategory = category;
        await SearchBooks();
    }

    private async Task OnPublisherChanged(PublisherDto? publisher)
    {
        selectedPublisher = publisher;
        await SearchBooks();
    }

    private async Task<PagedListDto<BookDto>> FetchBooksAsync(CancellationToken cancellationToken)
    {
        var request = new BookSearchRequest
        {
            Page = currentPage,
            PageSize = UIConstants.DefaultPageSize,
            Search = string.IsNullOrWhiteSpace(searchQuery) ? string.Empty : searchQuery,
            AuthorId = selectedAuthor?.Id,
            CategoryId = selectedCategory?.Id,
            PublisherId = selectedPublisher?.Id,
            OnSale = onSale ? true : null,
            MinPrice = minPrice,
            MaxPrice = maxPrice,
            Currency = CurrencyService.CurrentCurrency,
            SortBy = sortBy,
            SortOrder = sortOrder
        };

        return await BooksClient.GetBooksAsync(
            request, cancellationToken);
    }

    private void HandleNotification(BookStore.Shared.Notifications.IDomainEventNotification notification)
    {
        try
        {
            // Side effect: Confirm optimistic book if created
            if (notification is BookStore.Shared.Notifications.BookCreatedNotification bookCreated)
            {
                OptimisticService.ConfirmBook(bookCreated.EntityId);
            }
        }
        catch (OperationCanceledException)
        {
            // Expected during navigation
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Error processing notification in Home.");
        }
    }

    private void OnSearchKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            _ = SearchBooks();
            return;
        }

        // Debounce search
        debounceTimer?.Dispose();
        debounceTimer = new System.Threading.Timer(async _ => { await InvokeAsync(SearchBooks); }, null, UIConstants.DebounceDelay, Timeout.Infinite);
    }

    private async Task SearchBooks()
    {
        if (_disposed) return;
        currentPage = 1;
        if (bookQuery != null)
        {
            await bookQuery.LoadAsync(silent: true);
        }
    }

    private void ClearSearch()
    {
        searchQuery = string.Empty;
        _ = SearchBooks();
    }

    private void ClearFilters()
    {
        selectedAuthor = null;
        selectedCategory = null;
        selectedPublisher = null;
        minPrice = null;
        maxPrice = null;
        onSale = false;
        searchQuery = string.Empty;
        sortBy = "title";
        sortOrder = "asc";

        _ = SearchBooks();
    }

    private async Task LoadPage(int page)
    {
        if (_disposed) return;
        currentPage = page;
        if (bookQuery != null)
        {
            await bookQuery.LoadAsync(silent: true);
        }
    }

    private async Task ToggleFavorite(BookDto book)
    {
        await CatalogService.ToggleFavoriteAsync(book,
            setOptimistic: (newState) => bookQuery?.MutateData(currentList =>
            {
                var items = currentList.Items.ToList();
                var index = items.FindIndex(b => b.Id == book.Id);
                if (index != -1)
                {
                    items[index] = items[index] with
                    {
                        IsFavorite = newState,
                        LikeCount = newState ? items[index].LikeCount + 1 : items[index].LikeCount - 1
                    };
                }

                return new PagedListDto<BookDto>(
                    items,
                    currentList.PageNumber,
                    currentList.PageSize,
                    currentList.TotalItemCount
                );
            }),
            setRollback: (oldState) => bookQuery?.MutateData(currentList =>
            {
                var items = currentList.Items.ToList();
                var index = items.FindIndex(b => b.Id == book.Id);
                if (index != -1)
                {
                    items[index] = items[index] with
                    {
                        IsFavorite = oldState,
                        LikeCount = oldState ? items[index].LikeCount + 1 : items[index].LikeCount - 1
                    };
                }

                return new PagedListDto<BookDto>(
                    items,
                    currentList.PageNumber,
                    currentList.PageSize,
                    currentList.TotalItemCount
                );
            }),
            cancellationToken: _cts.Token);
    }

    private async Task RetryLoad()
    {
        if (_disposed) return;
        if (bookQuery != null)
        {
            await bookQuery.LoadAsync(cancellationToken: _cts.Token);
        }
    }

    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;

        OptimisticService.OnBooksChanged -= HandleOptimisticBooksChanged;
        EventsService.OnNotificationReceived -= HandleNotification;
        CurrencyService.OnCurrencyChanged -= HandleCurrencyChanged;
        TenantService.OnChange -= HandleTenantChanged;

        _cts.Cancel();
        _cts.Dispose();
        bookQuery?.Dispose();
        debounceTimer?.Dispose();
    }

    private void HandleOptimisticBooksChanged()
    {
        // Refresh UI when optimistic books change
        InvokeAsync(StateHasChanged);
    }

    private void StartCleanupTimer()
    {
        // Clean up stale optimistic books every 5 seconds
        cleanupTimer = new System.Threading.Timer(_ => { OptimisticService.CleanupStaleBooks(); }, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));
    }


}
